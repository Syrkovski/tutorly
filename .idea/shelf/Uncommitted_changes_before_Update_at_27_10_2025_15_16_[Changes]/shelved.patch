Index: app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.ui\r\n\r\nimport androidx.compose.animation.AnimatedContent\r\nimport androidx.compose.animation.ExperimentalAnimationApi\r\nimport androidx.compose.animation.core.tween\r\nimport androidx.compose.animation.fadeIn\r\nimport androidx.compose.animation.fadeOut\r\nimport androidx.compose.animation.slideInHorizontally\r\nimport androidx.compose.animation.slideOutHorizontally\r\nimport androidx.compose.animation.togetherWith\r\nimport androidx.compose.foundation.Canvas\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.clickable\r\nimport androidx.compose.foundation.gestures.detectHorizontalDragGestures\r\nimport androidx.compose.foundation.gestures.detectTapGestures\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.foundation.lazy.grid.GridCells\r\nimport androidx.compose.foundation.lazy.grid.LazyVerticalGrid\r\nimport androidx.compose.foundation.lazy.grid.items\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.verticalScroll\r\nimport androidx.compose.foundation.shape.CircleShape\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.outlined.Add\r\nimport androidx.compose.material.icons.outlined.Settings\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.material3.TabRowDefaults.tabIndicatorOffset\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.runtime.collectAsState\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.draw.clip\r\nimport androidx.compose.ui.draw.clipToBounds\r\nimport androidx.compose.ui.draw.drawBehind\r\nimport androidx.compose.ui.draw.shadow\r\nimport androidx.compose.ui.geometry.CornerRadius\r\nimport androidx.compose.ui.geometry.Offset\r\nimport androidx.compose.ui.geometry.Size\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.ui.graphics.drawscope.Stroke\r\nimport androidx.compose.ui.input.pointer.pointerInput\r\n//import androidx.compose.ui.layout.wrapContentSize\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.platform.LocalDensity\r\nimport androidx.compose.ui.res.stringResource\r\nimport androidx.compose.ui.text.style.TextAlign\r\nimport androidx.compose.ui.text.style.TextOverflow\r\nimport androidx.compose.ui.unit.Dp\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.hilt.navigation.compose.hiltViewModel\r\nimport android.app.DatePickerDialog\r\nimport com.tutorly.R\r\nimport com.tutorly.ui.CalendarEvent\r\nimport com.tutorly.models.PaymentStatus\r\nimport com.tutorly.ui.components.LessonBrief\r\nimport com.tutorly.ui.components.StatusChipData\r\nimport com.tutorly.ui.components.TopBarContainer\r\nimport com.tutorly.ui.components.WeekMosaic\r\nimport com.tutorly.ui.components.statusChipData\r\nimport com.tutorly.ui.screens.normalizeGrade\r\nimport com.tutorly.ui.theme.extendedColors\r\nimport com.tutorly.ui.lessoncreation.LessonCreationConfig\r\nimport com.tutorly.ui.lessoncreation.LessonCreationOrigin\r\nimport com.tutorly.ui.lessoncreation.LessonCreationSheet\r\nimport com.tutorly.ui.lessoncreation.LessonCreationViewModel\r\nimport com.tutorly.ui.lessoncard.LessonCardSheet\r\nimport com.tutorly.ui.lessoncard.LessonCardViewModel\r\nimport java.time.DayOfWeek\r\nimport java.time.Duration\r\nimport java.time.LocalDate\r\nimport java.time.LocalTime\r\nimport java.time.ZonedDateTime\r\nimport java.time.ZoneId\r\nimport java.time.format.DateTimeFormatter\r\nimport java.time.format.TextStyle\r\nimport java.util.*\r\nimport kotlin.math.abs\r\nimport kotlin.math.roundToInt\r\n\r\nenum class CalendarMode { DAY, WEEK }\r\n\r\n@OptIn(ExperimentalAnimationApi::class)\r\n@Composable\r\nfun CalendarScreen(\r\n    modifier: Modifier = Modifier,\r\n    onAddStudent: () -> Unit = {},\r\n    onOpenSettings: () -> Unit = {},\r\n    creationViewModel: LessonCreationViewModel,\r\n    viewModel: CalendarViewModel = hiltViewModel()\r\n) {\r\n    val uiState by viewModel.uiState.collectAsState()\r\n    val creationState by creationViewModel.uiState.collectAsState()\r\n    val lessonCardViewModel: LessonCardViewModel = hiltViewModel()\r\n    val lessonCardState by lessonCardViewModel.uiState.collectAsState()\r\n    val snackbarHostState = remember { SnackbarHostState() }\r\n    var direction by remember { mutableStateOf(0) } // -1 назад, +1 вперёд\r\n    val anchor = uiState.anchor\r\n    val mode = uiState.mode\r\n    val zoneId = remember { ZoneId.systemDefault() }\r\n\r\n    LaunchedEffect(mode) {\r\n    }\r\n\r\n    LessonCardSheet(\r\n        state = lessonCardState,\r\n        onDismissRequest = lessonCardViewModel::dismiss,\r\n        onStudentSelect = lessonCardViewModel::onStudentSelected,\r\n        onAddStudent = {\r\n            lessonCardViewModel.dismiss()\r\n            creationViewModel.prepareForStudentCreation()\r\n            onAddStudent()\r\n        },\r\n        onDateSelect = lessonCardViewModel::onDateSelected,\r\n        onTimeSelect = lessonCardViewModel::onTimeSelected,\r\n        onDurationSelect = lessonCardViewModel::onDurationSelected,\r\n        onPriceChange = lessonCardViewModel::onPriceChanged,\r\n        onStatusSelect = lessonCardViewModel::onPaymentStatusSelected,\r\n        onNoteChange = lessonCardViewModel::onNoteChanged,\r\n        onDeleteLesson = lessonCardViewModel::deleteLesson,\r\n        onSnackbarConsumed = lessonCardViewModel::consumeSnackbar\r\n    )\r\n\r\n    LaunchedEffect(viewModel) {\r\n        viewModel.events.collect { event ->\r\n            when (event) {\r\n                is CalendarEvent.CreateLesson -> creationViewModel.start(\r\n                    LessonCreationConfig(\r\n                        start = event.start,\r\n                        duration = event.duration,\r\n                        studentId = event.studentId,\r\n                        zoneId = event.start.zone,\r\n                        origin = LessonCreationOrigin.CALENDAR\r\n                    )\r\n                )\r\n                is CalendarEvent.OpenLesson -> lessonCardViewModel.open(event.lessonId)\r\n            }\r\n        }\r\n    }\r\n\r\n    LaunchedEffect(creationState.snackbarMessage) {\r\n        creationState.snackbarMessage?.let { message ->\r\n            snackbarHostState.showSnackbar(message)\r\n            creationViewModel.consumeSnackbar()\r\n        }\r\n    }\r\n\r\n    LessonCreationSheet(\r\n        state = creationState,\r\n        onDismiss = { creationViewModel.dismiss() },\r\n        onStudentQueryChange = creationViewModel::onStudentQueryChange,\r\n        onStudentGradeChange = creationViewModel::onStudentGradeChanged,\r\n        onStudentSelect = creationViewModel::onStudentSelected,\r\n        onSubjectInputChange = creationViewModel::onSubjectInputChanged,\r\n        onSubjectSelect = creationViewModel::onSubjectSelected,\r\n        onSubjectSuggestionToggle = creationViewModel::onSubjectSuggestionToggled,\r\n        onSubjectChipRemove = creationViewModel::onSubjectChipRemoved,\r\n        onDateSelect = creationViewModel::onDateSelected,\r\n        onTimeSelect = creationViewModel::onTimeSelected,\r\n        onDurationChange = creationViewModel::onDurationChanged,\r\n        onPriceChange = creationViewModel::onPriceChanged,\r\n        onNoteChange = creationViewModel::onNoteChanged,\r\n        onSubmit = creationViewModel::submit,\r\n        onConfirmConflict = creationViewModel::confirmConflict,\r\n        onDismissConflict = creationViewModel::dismissConflict\r\n    )\r\n\r\n    val prevPeriod = {\r\n        direction = -1\r\n        viewModel.goToPreviousPeriod()\r\n    }\r\n    val nextPeriod = {\r\n        direction = +1\r\n        viewModel.goToNextPeriod()\r\n    }\r\n\r\n    val swipeModifier = Modifier.pointerInput(mode) {\r\n        val threshold = 48.dp.toPx()\r\n        var totalDrag = 0f\r\n        var handled = false\r\n        detectHorizontalDragGestures(\r\n            onDragStart = {\r\n                totalDrag = 0f\r\n                handled = false\r\n            },\r\n            onDragEnd = {\r\n                totalDrag = 0f\r\n                handled = false\r\n            },\r\n            onDragCancel = {\r\n                totalDrag = 0f\r\n                handled = false\r\n            },\r\n            onHorizontalDrag = { change, dragAmount ->\r\n                if (handled) return@detectHorizontalDragGestures\r\n\r\n                totalDrag += dragAmount\r\n                if (abs(totalDrag) > threshold) {\r\n                    if (totalDrag < 0) nextPeriod() else prevPeriod()\r\n                    handled = true\r\n                    change.consume()\r\n                }\r\n            }\r\n        )\r\n    }\r\n\r\n    val handleSelectDate: (LocalDate) -> Unit = { selected ->\r\n        direction = when {\r\n            selected.isAfter(anchor) -> 1\r\n            selected.isBefore(anchor) -> -1\r\n            else -> 0\r\n        }\r\n        viewModel.selectDate(selected)\r\n    }\r\n\r\n    Scaffold(\r\n        modifier = modifier,\r\n        topBar = {\r\n            CalendarTopBar(\r\n                anchor = anchor,\r\n                onSelectDate = handleSelectDate,\r\n                onOpenSettings = onOpenSettings\r\n            )\r\n        },\r\n        snackbarHost = { SnackbarHost(snackbarHostState) },\r\n        floatingActionButton = {\r\n            FloatingActionButton(\r\n                onClick = {\r\n                    val start = uiState.currentDateTime\r\n                    creationViewModel.start(\r\n                        LessonCreationConfig(\r\n                            start = start,\r\n                            zoneId = uiState.zoneId,\r\n                            origin = LessonCreationOrigin.CALENDAR\r\n                        )\r\n                    )\r\n                },\r\n                containerColor = MaterialTheme.extendedColors.accent,\r\n                contentColor = MaterialTheme.colorScheme.onPrimary\r\n            ) {\r\n                Icon(\r\n                    imageVector = Icons.Outlined.Add,\r\n                    contentDescription = stringResource(id = R.string.lesson_create_title)\r\n                )\r\n            }\r\n\r\n//            containerColor = Color.Transparent\r\n        }\r\n    ) { padding ->\r\n        Column(\r\n            Modifier\r\n                .fillMaxSize()\r\n                .padding(padding)\r\n        ) {\r\n            CalendarTimelineHeader(\r\n                anchor = anchor,\r\n                currentDateTime = uiState.currentDateTime,\r\n                mode = mode,\r\n                onSelectDate = handleSelectDate,\r\n                onSelectMode = { newMode ->\r\n                    direction = 0\r\n                    viewModel.setMode(newMode)\r\n                },\r\n                onSwipeLeft = nextPeriod,\r\n                onSwipeRight = prevPeriod\r\n            )\r\n\r\n            // Контент занимает остаток экрана и скроллится внутри\r\n        Box(\r\n            Modifier\r\n                .weight(1f)\r\n                .fillMaxWidth()\r\n                .clipToBounds()\r\n                .then(swipeModifier)   // \uD83D\uDC48 свайп теперь работает по всему экрану\r\n        ) {\r\n            val workdayBounds = remember(uiState.workDayStartMinutes, uiState.workDayEndMinutes) {\r\n                sanitizeWorkdayBounds(\r\n                    startMinutes = uiState.workDayStartMinutes,\r\n                    endMinutes = uiState.workDayEndMinutes\r\n                )\r\n            }\r\n\r\n            AnimatedContent(\r\n                targetState = anchor,\r\n                modifier = Modifier.fillMaxSize(),\r\n                transitionSpec = {\r\n                    if (direction > 0) {\r\n                        // вперёд (влево)\r\n                        (slideInHorizontally(\r\n                            initialOffsetX = { fullWidth -> fullWidth },\r\n                            animationSpec = tween(durationMillis = 250)\r\n                        ) + fadeIn(animationSpec = tween(250))) togetherWith\r\n                                (slideOutHorizontally(\r\n                                    targetOffsetX = { fullWidth -> -fullWidth / 2 },\r\n                                    animationSpec = tween(durationMillis = 250)\r\n                                ) + fadeOut(animationSpec = tween(250)))\r\n                    } else {\r\n                        // назад (вправо)\r\n                        (slideInHorizontally(\r\n                            initialOffsetX = { fullWidth -> -fullWidth },\r\n                            animationSpec = tween(durationMillis = 250)\r\n                        ) + fadeIn(animationSpec = tween(250))) togetherWith\r\n                                (slideOutHorizontally(\r\n                                    targetOffsetX = { fullWidth -> fullWidth / 2 },\r\n                                    animationSpec = tween(durationMillis = 250)\r\n                                ) + fadeOut(animationSpec = tween(250)))\r\n                    }\r\n                },\r\n                label = \"day-switch\"\r\n            ) { currentDate ->\r\n                val lessonsForCurrent = remember(\r\n                    currentDate,\r\n                    uiState.lessonsByDate,\r\n                    workdayBounds\r\n                ) {\r\n                    uiState.lessonsByDate[currentDate]\r\n                        .orEmpty()\r\n                        .filter { lesson ->\r\n                            lesson.isWithinBounds(currentDate, workdayBounds)\r\n                        }\r\n                }\r\n                when (mode) {\r\n                    CalendarMode.DAY -> DayTimeline(\r\n                        date = currentDate,\r\n                        lessons = lessonsForCurrent,\r\n                        currentDateTime = uiState.currentDateTime,\r\n                        workDayStartMinutes = workdayBounds.startMinutes,\r\n                        workDayEndMinutes = workdayBounds.endMinutes,\r\n                        onLessonClick = { lesson ->\r\n                            lessonCardViewModel.open(lesson.id)\r\n                        },\r\n                        onEmptySlot = { startTime ->\r\n                            viewModel.onEmptySlotSelected(\r\n                                currentDate,\r\n                                startTime,\r\n                                DefaultSlotDuration\r\n                            )\r\n                        }\r\n                    )\r\n\r\n                    CalendarMode.WEEK -> WeekMosaic(\r\n                        anchor = currentDate,\r\n                        onOpenDay = { selected ->\r\n                            direction = when {\r\n                                selected.isAfter(anchor) -> 1\r\n                                selected.isBefore(anchor) -> -1\r\n                                else -> 0\r\n                            }\r\n                            viewModel.setMode(CalendarMode.DAY)\r\n                            viewModel.selectDate(selected)\r\n                        },\r\n                        dayDataProvider = { date ->\r\n                            uiState.lessonsByDate[date]\r\n                                .orEmpty()\r\n                                .filter { lesson ->\r\n                                    lesson.isWithinBounds(date, workdayBounds)\r\n                                }\r\n                                .map { it.toLessonBrief() }\r\n                        },\r\n                        currentDateTime = uiState.currentDateTime,\r\n                        onLessonClick = { brief -> lessonCardViewModel.open(brief.id) }\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate fun CalendarLesson.toLessonBrief(): LessonBrief {\r\n    return LessonBrief(\r\n        id = id,\r\n        start = start,\r\n        end = end,\r\n        student = studentName,\r\n        grade = studentGrade,\r\n        subjectName = subjectName,\r\n        subjectColorArgb = subjectColorArgb,\r\n        paymentStatus = paymentStatus\r\n    )\r\n}\r\n\r\nprivate fun CalendarLesson.isWithinBounds(date: LocalDate, bounds: WorkdayBounds): Boolean {\r\n    if (start.toLocalDate() != date) return false\r\n\r\n    val lessonStartMinutes = start.hour * MinutesPerHour + start.minute\r\n    val lessonEndMinutes = if (end.toLocalDate().isAfter(date)) {\r\n        val overflowMinutes = Duration.between(\r\n            date.plusDays(1).atStartOfDay(end.zone),\r\n            end\r\n        ).toMinutes().toInt()\r\n        MINUTES_IN_DAY + overflowMinutes\r\n    } else {\r\n        end.hour * MinutesPerHour + end.minute\r\n    }\r\n\r\n    if (lessonEndMinutes <= lessonStartMinutes) return false\r\n\r\n    return lessonStartMinutes >= bounds.startMinutes && lessonEndMinutes <= bounds.endMinutes\r\n}\r\n\r\n\r\n/* ----------------------------- TOP BAR ----------------------------------- */\r\n\r\n@Composable\r\nfun CalendarTopBar(\r\n    anchor: LocalDate,\r\n    onSelectDate: (LocalDate) -> Unit,\r\n    onOpenSettings: () -> Unit\r\n) {\r\n    val locale = remember { Locale(\"ru\") }\r\n    val monthFormatter = remember(locale) { DateTimeFormatter.ofPattern(\"LLLL yyyy\", locale) }\r\n    val monthLabel = remember(anchor, locale) {\r\n        val raw = monthFormatter.format(anchor)\r\n        raw.replaceFirstChar { if (it.isLowerCase()) it.titlecase(locale) else it.toString() }\r\n    }\r\n    var showDatePicker by remember { mutableStateOf(false) }\r\n    val context = LocalContext.current\r\n\r\n    TopBarContainer {\r\n        Box(\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .height(80.dp)\r\n                .padding(horizontal = 16.dp)\r\n        ) {\r\n            Text(\r\n                text = monthLabel,\r\n                style = MaterialTheme.typography.titleLarge,\r\n                color = MaterialTheme.colorScheme.surface,\r\n                modifier = Modifier\r\n                    .align(Alignment.Center)\r\n//                    .padding(horizontal = 96.dp)\r\n                    .clickable { showDatePicker = true },\r\n                textAlign = TextAlign.Center,\r\n                maxLines = 1,\r\n                overflow = TextOverflow.Ellipsis\r\n            )\r\n            IconButton(\r\n                onClick = onOpenSettings,\r\n                modifier = Modifier.align(Alignment.CenterEnd),\r\n                colors = IconButtonDefaults.iconButtonColors(\r\n                    contentColor = MaterialTheme.colorScheme.surface\r\n                )\r\n            ) {\r\n                Icon(\r\n                    imageVector = Icons.Outlined.Settings,\r\n                    contentDescription = stringResource(id = R.string.settings_title)\r\n                )\r\n            }\r\n        }\r\n    }\r\n\r\n    if (showDatePicker) {\r\n        DisposableEffect(anchor) {\r\n            val picker = DatePickerDialog(\r\n                context,\r\n                { _, year, month, dayOfMonth ->\r\n                    showDatePicker = false\r\n                    onSelectDate(LocalDate.of(year, month + 1, dayOfMonth))\r\n                },\r\n                anchor.year,\r\n                anchor.monthValue - 1,\r\n                anchor.dayOfMonth\r\n            )\r\n            picker.setOnDismissListener { showDatePicker = false }\r\n            picker.show()\r\n            onDispose {\r\n                picker.setOnDismissListener(null)\r\n                if (picker.isShowing) {\r\n                    picker.dismiss()\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun CalendarTimelineHeader(\r\n    anchor: LocalDate,\r\n    currentDateTime: ZonedDateTime,\r\n    mode: CalendarMode,\r\n    onSelectDate: (LocalDate) -> Unit,\r\n    onSelectMode: (CalendarMode) -> Unit,\r\n    onSwipeLeft: () -> Unit,\r\n    onSwipeRight: () -> Unit,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    val locale = remember { Locale(\"ru\") }\r\n    val weekStart = remember(anchor) { anchor.with(DayOfWeek.MONDAY) }\r\n    val weekDays = remember(weekStart) { (0 until 7).map { weekStart.plusDays(it.toLong()) } }\r\n    val today = remember(currentDateTime) { currentDateTime.toLocalDate() }\r\n\r\n    Column(\r\n        modifier = modifier\r\n            .fillMaxWidth()\r\n            .background(Color(0xFFFEFEFE))\r\n    ) {\r\n        Spacer(Modifier.height(12.dp))\r\n\r\n        Row(\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .padding(horizontal = 16.dp)\r\n                .padding(bottom = 4.dp),\r\n            horizontalArrangement = Arrangement.SpaceBetween,\r\n            verticalAlignment = Alignment.CenterVertically\r\n        ) {\r\n            weekDays.forEach { day ->\r\n                WeekDayCell(\r\n                    modifier = Modifier.weight(1f),\r\n                    date = day,\r\n                    isSelected = day == anchor,\r\n                    isToday = day == today,\r\n                    locale = locale,\r\n                    onClick = { onSelectDate(day) }\r\n                )\r\n            }\r\n        }\r\n\r\n        CalendarModeToggle(\r\n            selected = mode,\r\n            onSelect = onSelectMode,\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .padding(bottom = 4.dp)\r\n                .pointerInput(mode) {\r\n                    val threshold = 48.dp.toPx()\r\n                    var totalDrag = 0f\r\n                    var handled = false\r\n                    detectHorizontalDragGestures(\r\n                        onDragStart = {\r\n                            totalDrag = 0f\r\n                            handled = false\r\n                        },\r\n                        onDragEnd = {\r\n                            totalDrag = 0f\r\n                            handled = false\r\n                        },\r\n                        onDragCancel = {\r\n                            totalDrag = 0f\r\n                            handled = false\r\n                        },\r\n                        onHorizontalDrag = { change, dragAmount ->\r\n                            if (handled) return@detectHorizontalDragGestures\r\n\r\n                            totalDrag += dragAmount\r\n                            if (abs(totalDrag) > threshold) {\r\n                                if (totalDrag < 0) onSwipeLeft() else onSwipeRight()\r\n                                handled = true\r\n                                change.consume()\r\n                            }\r\n                        }\r\n                    )\r\n                }\r\n        )\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun CalendarModeToggle(\r\n    selected: CalendarMode,\r\n    onSelect: (CalendarMode) -> Unit,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    val options = remember { listOf(CalendarMode.DAY, CalendarMode.WEEK) }\r\n    val selectedIndex = options.indexOf(selected).coerceAtLeast(0)\r\n    val accent = MaterialTheme.extendedColors.accent\r\n    val inactiveColor = Color(0xFFB9BCC7)\r\n    TabRow(\r\n        selectedTabIndex = selectedIndex,\r\n        modifier = modifier,\r\n//        containerColor = Color(0xFFFEFEFE),\r\n        contentColor = MaterialTheme.colorScheme.onSurface,\r\n        divider = {},\r\n        indicator = { tabPositions ->\r\n            if (selectedIndex in tabPositions.indices) {\r\n                val position = tabPositions[selectedIndex]\r\n                Box(\r\n                    modifier = Modifier\r\n                        .fillMaxWidth()\r\n                        .wrapContentSize(Alignment.BottomStart)\r\n                ) {\r\n                    Box(\r\n                        modifier = Modifier\r\n                            .tabIndicatorOffset(position)\r\n                            .padding(horizontal = 38.dp)\r\n                            .height(3.dp)\r\n                            .clip(RoundedCornerShape(topStart = 3.dp, topEnd = 3.dp))\r\n                            .background(accent)\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    ) {\r\n        options.forEachIndexed { index, option ->\r\n            val labelRes = if (option == CalendarMode.DAY) {\r\n                R.string.calendar_mode_day\r\n            } else {\r\n                R.string.calendar_mode_week\r\n            }\r\n            val isSelected = index == selectedIndex\r\n            Tab(\r\n                selected = isSelected,\r\n                onClick = {\r\n                    if (!isSelected) onSelect(option)\r\n                }\r\n            ) {\r\n                Box(\r\n                    modifier = Modifier\r\n                        .fillMaxWidth()\r\n                        .padding(vertical = 12.dp),\r\n                    contentAlignment = Alignment.Center\r\n                ) {\r\n                    Text(\r\n                        text = stringResource(id = labelRes),\r\n                        style = MaterialTheme.typography.titleMedium,\r\n                        color = if (isSelected) {\r\n                            MaterialTheme.colorScheme.onSurface\r\n                        } else {\r\n                            inactiveColor\r\n                        }\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n@Composable\r\nprivate fun WeekDayCell(\r\n    modifier: Modifier = Modifier,\r\n    date: LocalDate,\r\n    isSelected: Boolean,\r\n    isToday: Boolean,\r\n    locale: Locale,\r\n    onClick: () -> Unit\r\n) {\r\n    val accent = MaterialTheme.extendedColors.accent\r\n    val label = remember(date, locale) {\r\n        date.dayOfWeek.getDisplayName(TextStyle.SHORT, locale)\r\n            .replaceFirstChar { if (it.isLowerCase()) it.titlecase(locale) else it.toString() }\r\n    }\r\n    val number = remember(date) { date.dayOfMonth.toString() }\r\n    val circleColor = if (isSelected) accent else Color.Transparent\r\n    val numberColor = if (isSelected) Color.White else MaterialTheme.colorScheme.onSurface\r\n    val labelColor = Color(0xFFB9BCC7)\r\n\r\n    Column(\r\n        modifier = modifier\r\n            .width(40.dp)\r\n\r\n            .clickable(onClick = onClick)\r\n            .padding(vertical = 0.dp, horizontal = 4.dp),\r\n        horizontalAlignment = Alignment.CenterHorizontally,\r\n        verticalArrangement = Arrangement.spacedBy(8.dp, Alignment.CenterVertically)\r\n    ) {\r\n        Text(\r\n            text = label,\r\n            style = MaterialTheme.typography.labelMedium,\r\n            color = labelColor\r\n        )\r\n        Box(\r\n            modifier = Modifier\r\n                .height(40.dp)\r\n                .width(40.dp)\r\n                .clip(CircleShape)\r\n                .shadow(if (isSelected) 6.dp else 0.dp, CircleShape, clip = false)\r\n                .background(circleColor),\r\n            contentAlignment = Alignment.Center\r\n        ) {\r\n            Text(\r\n                text = number,\r\n                style = MaterialTheme.typography.titleMedium,\r\n                color = numberColor\r\n            )\r\n        }\r\n        if (isToday && !isSelected) {\r\n            Box(\r\n                modifier = Modifier\r\n                    .size(6.dp)\r\n                    .clip(CircleShape)\r\n                    .background(accent)\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n/* --------------------------- DAY TIMELINE -------------------------------- */\r\n\r\nprivate val LabelWidth = 64.dp\r\nprivate val HourHeight = 80.dp\r\nprivate val DefaultSlotDuration: Duration = Duration.ofMinutes(60)\r\nprivate const val MinutesPerHour: Int = 60\r\nprivate const val SlotIncrementMinutes: Int = 30\r\nprivate const val MINUTES_IN_DAY: Int = MinutesPerHour * 24\r\nprivate const val MAX_END_MINUTE: Int = MINUTES_IN_DAY\r\nprivate const val MAX_START_MINUTE: Int = MAX_END_MINUTE - SlotIncrementMinutes\r\n\r\nprivate data class WorkdayBounds(\r\n    val startMinutes: Int,\r\n    val endMinutes: Int\r\n)\r\n\r\nprivate fun sanitizeWorkdayBounds(startMinutes: Int, endMinutes: Int): WorkdayBounds {\r\n    val sanitizedStart = startMinutes.coerceIn(0, MAX_START_MINUTE)\r\n    val sanitizedEnd = endMinutes.coerceIn(\r\n        sanitizedStart + SlotIncrementMinutes,\r\n        MAX_END_MINUTE\r\n    )\r\n    return WorkdayBounds(\r\n        startMinutes = sanitizedStart,\r\n        endMinutes = sanitizedEnd\r\n    )\r\n}\r\n\r\n@Composable\r\nprivate fun DayTimeline(\r\n    date: LocalDate,\r\n    lessons: List<CalendarLesson>,\r\n    currentDateTime: ZonedDateTime,\r\n    workDayStartMinutes: Int,\r\n    workDayEndMinutes: Int,\r\n    onLessonClick: (CalendarLesson) -> Unit,\r\n    onEmptySlot: (LocalTime) -> Unit\r\n) {\r\n    val dayLessons = remember(date, lessons) { lessons }\r\n    val isToday = remember(date, currentDateTime) { currentDateTime.toLocalDate() == date }\r\n    val startMinutes = remember(workDayStartMinutes) {\r\n        workDayStartMinutes.coerceIn(0, MAX_START_MINUTE)\r\n    }\r\n    val endMinutes = remember(workDayEndMinutes, startMinutes) {\r\n        workDayEndMinutes.coerceIn(startMinutes + SlotIncrementMinutes, MAX_END_MINUTE)\r\n    }\r\n    val totalMinutes = remember(startMinutes, endMinutes) {\r\n        (endMinutes - startMinutes).coerceAtLeast(SlotIncrementMinutes)\r\n    }\r\n    val minuteHeight = remember { HourHeight / MinutesPerHour }\r\n    val totalHeight = remember(totalMinutes) { minuteHeight * totalMinutes.toFloat() }\r\n\r\n    val scroll = rememberScrollState()\r\n    val density = LocalDensity.current\r\n    val minuteHeightPx = remember(density) { with(density) { minuteHeight.toPx() } }\r\n    val labelWidthPx = remember(density) { with(density) { LabelWidth.toPx() } }\r\n    val cardInsetPx = remember(density) { with(density) { 16.dp.toPx() } }\r\n    val totalHeightPx = remember(totalHeight, density) { with(density) { totalHeight.toPx() } }\r\n    val nowMinutesFromStart = remember(isToday, currentDateTime, startMinutes, totalMinutes) {\r\n        if (!isToday) {\r\n            null\r\n        } else {\r\n            val currentMinutes = currentDateTime.hour * MinutesPerHour + currentDateTime.minute\r\n            val within = currentMinutes - startMinutes\r\n            within.takeIf { it in 0..totalMinutes }\r\n        }\r\n    }\r\n    val hourMarks = remember(startMinutes, endMinutes) {\r\n        buildList {\r\n            add(startMinutes)\r\n            var next = ((startMinutes / MinutesPerHour) + 1) * MinutesPerHour\r\n            while (next < endMinutes) {\r\n                add(next)\r\n                next += MinutesPerHour\r\n            }\r\n            add(endMinutes)\r\n        }.distinct()\r\n    }\r\n    val labelMinutes = remember(startMinutes, endMinutes) {\r\n        buildList {\r\n            add(startMinutes)\r\n            var next = ((startMinutes / MinutesPerHour) + 1) * MinutesPerHour\r\n            while (next < endMinutes) {\r\n                add(next)\r\n                next += MinutesPerHour\r\n            }\r\n        }\r\n    }\r\n    val lessonRegions = remember(dayLessons, startMinutes, minuteHeightPx, labelWidthPx, cardInsetPx) {\r\n        val baseMin = startMinutes\r\n        dayLessons.map { lesson ->\r\n            val startTime = lesson.start.toLocalTime()\r\n            val lessonStart = startTime.hour * MinutesPerHour + startTime.minute\r\n            val offsetMinutes = (lessonStart - baseMin).coerceAtLeast(0)\r\n            val durationMinutes = lesson.duration.toMinutes().coerceAtLeast(SlotIncrementMinutes.toLong())\r\n            val topPx = offsetMinutes * minuteHeightPx\r\n            val heightPx = durationMinutes.toFloat() * minuteHeightPx\r\n            TimelineLessonRegion(\r\n                topPx = topPx,\r\n                bottomPx = topPx + heightPx,\r\n                leftPx = labelWidthPx + cardInsetPx\r\n            )\r\n        }\r\n    }\r\n\r\n    Box(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n//            .background(MaterialTheme.colorScheme.surfaceVariant)\r\n            .padding(horizontal = 0.dp, vertical = 0.dp)\r\n    ) {\r\n        Card(\r\n            modifier = Modifier.fillMaxSize(),\r\n//            shape = RoundedCornerShape(28.dp),\r\n//            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),\r\n//            elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)\r\n        ) {\r\n            Column(\r\n                modifier = Modifier\r\n                    .fillMaxSize()\r\n                    .verticalScroll(scroll)\r\n            ) {\r\n                Spacer(modifier = Modifier.height(24.dp))\r\n                Box(\r\n                    Modifier\r\n                        .fillMaxWidth()\r\n                        .height(totalHeight)\r\n                        .padding(horizontal = 0.dp, vertical = 0.dp)\r\n                        .pointerInput(dayLessons, startMinutes, endMinutes, lessonRegions) {\r\n                            detectTapGestures { offset ->\r\n                                if (offset.x < labelWidthPx) return@detectTapGestures\r\n                                if (lessonRegions.any { region ->\r\n                                        offset.x >= region.leftPx && offset.y in region.topPx..region.bottomPx\r\n                                    }\r\n                                ) {\r\n                                    return@detectTapGestures\r\n                                }\r\n\r\n                                val clampedY = offset.y.coerceIn(0f, totalHeightPx)\r\n                                val minutesWithin = (clampedY / minuteHeightPx).roundToInt()\r\n                                val candidate = startMinutes + minutesWithin\r\n                                val maxSelectable = (endMinutes - SlotIncrementMinutes).coerceAtLeast(startMinutes)\r\n                                val normalized = candidate.coerceIn(startMinutes, maxSelectable)\r\n                                val slots = (normalized - startMinutes) / SlotIncrementMinutes\r\n                                val rounded = startMinutes + slots * SlotIncrementMinutes\r\n                                val hour = rounded / MinutesPerHour\r\n                                val minute = rounded % MinutesPerHour\r\n                                onEmptySlot(LocalTime.of(hour, minute))\r\n                            }\r\n                        }\r\n                ) {\r\n                    val gridLineColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.06f)\r\n                    val accent = MaterialTheme.extendedColors.accent\r\n                    val circleColor = MaterialTheme.colorScheme.background\r\n                    Canvas(Modifier.matchParentSize()) {\r\n                        val leftPad = LabelWidth.toPx()\r\n                        val spineW = 2.dp.toPx()\r\n                        hourMarks.forEach { minute ->\r\n                            val y = (minute - startMinutes) * minuteHeightPx\r\n                            drawLine(\r\n                                color = gridLineColor,\r\n                                start = Offset(20f, y),\r\n                                end = Offset(size.width-20, y),\r\n                                strokeWidth = 1.dp.toPx()\r\n                            )\r\n                        }\r\n                        drawRect(\r\n                            color = accent,\r\n                            topLeft = Offset(leftPad - spineW / 2f, 0f),\r\n                            size = Size(spineW, size.height)\r\n                        )\r\n//                        nowMinutesFromStart?.let { minutes ->\r\n//                            val y = minutes * minuteHeightPx\r\n//                            drawLine(\r\n//                                color = accent,\r\n//                                start = Offset(leftPad, y),\r\n//                                end = Offset(size.width, y),\r\n//                                strokeWidth = 2.dp.toPx()\r\n//                            )\r\n//                        }\r\n                        nowMinutesFromStart?.let { minutes ->\r\n                            val y = minutes * minuteHeightPx\r\n\r\n                            val lineWidth = 2.dp.toPx()\r\n                            val ringStroke = 2.dp.toPx()\r\n                            val circleRadiusWhite = 12.dp.toPx()\r\n                            val circleRadiusAccentRing = 8.dp.toPx()\r\n                            val circleRadiusAccent = 5.dp.toPx()// подберёшь по вкусу\r\n                            val circleCx = leftPad                   // центр кружка на оси времени\r\n\r\n                            // 1) Линия от кружка вправо (чтобы не «перечёркивала» центр)\r\n//                            drawLine(\r\n//                                color = accent,\r\n//                                start = Offset(circleCx + circleRadius, y),\r\n//                                end   = Offset(size.width, y),\r\n//                                strokeWidth = lineWidth\r\n//                            )\r\n\r\n                            // 2) Белый «фон» кружка (чтобы перекрыть вертикальную ось/линии под ним)\r\n                            drawCircle(\r\n                                color = circleColor,\r\n                                radius = circleRadiusWhite,\r\n                                center = Offset(circleCx, y)\r\n                            )\r\n\r\n                            // 3) Акцентное кольцо (как на скрине)\r\n                            drawCircle(\r\n                                color = accent,\r\n                                radius = circleRadiusAccentRing,\r\n                                center = Offset(circleCx, y),\r\n                                style = Stroke(width = ringStroke)\r\n                            )\r\n\r\n                            drawCircle(\r\n                                color = accent,\r\n                                radius = circleRadiusAccent,\r\n                                center = Offset(circleCx, y),\r\n//                                style = Stroke(width = ringStroke)\r\n                            )\r\n                        }\r\n                    }\r\n\r\n                    dayLessons.forEach { lesson ->\r\n                        LessonBlock(\r\n                            lesson = lesson,\r\n                            baseMinutes = startMinutes,\r\n                            minuteHeight = minuteHeight,\r\n                            now = currentDateTime,\r\n                            onLessonClick = onLessonClick\r\n                        )\r\n                    }\r\n\r\n                    Box(\r\n                        Modifier\r\n                            .fillMaxHeight()\r\n                            .width(LabelWidth)\r\n                    ) {\r\n                        labelMinutes.forEach { minute ->\r\n                            val label = \"%02d:%02d\".format(minute / MinutesPerHour, minute % MinutesPerHour)\r\n                            Text(\r\n                                text = label,\r\n                                style = MaterialTheme.typography.labelLarge,\r\n                                color = MaterialTheme.colorScheme.onSurfaceVariant,\r\n                                modifier = Modifier\r\n                                    .align(Alignment.TopStart)\r\n                                    .offset(y = minuteHeight * (minute - startMinutes).toFloat()+8.dp, x=8.dp)\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate data class TimelineLessonRegion(\r\n    val topPx: Float,\r\n    val bottomPx: Float,\r\n    val leftPx: Float\r\n)\r\n\r\n@Composable\r\nprivate fun LessonBlock(\r\n    lesson: CalendarLesson,\r\n    baseMinutes: Int,\r\n    minuteHeight: Dp,\r\n    now: ZonedDateTime,\r\n    onLessonClick: (CalendarLesson) -> Unit\r\n) {\r\n    val startTime = lesson.start.toLocalTime()\r\n    val startMin = startTime.hour * MinutesPerHour + startTime.minute\r\n    val offsetMinutes = (startMin - baseMinutes).coerceAtLeast(0)\r\n    val durationMinutes = lesson.duration.toMinutes().coerceAtLeast(SlotIncrementMinutes.toLong())\r\n\r\n    val top = minuteHeight * offsetMinutes.toFloat()\r\n    val height = minuteHeight * durationMinutes.toInt().toFloat()\r\n\r\n    val lessonUi = lesson.toLessonUi(now)\r\n\r\n    Box(\r\n        Modifier\r\n            .fillMaxWidth()\r\n            .offset(y = top+4.dp)\r\n            .height(height-8.dp)\r\n            .padding(start = LabelWidth + 16.dp, end = 20.dp)\r\n            .clip(RoundedCornerShape(12.dp))\r\n    ) {\r\n        val cardShape = RoundedCornerShape(12.dp)\r\n        val innerStrokeWidth = 1.dp\r\n        Card(\r\n            modifier = Modifier.fillMaxSize(),\r\n            onClick = { onLessonClick(lesson) },\r\n            shape = cardShape,\r\n            colors = CardDefaults.cardColors(containerColor = Color.White),\r\n            elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)\r\n        ) {\r\n            Box(\r\n                modifier = Modifier\r\n                    .fillMaxSize()\r\n                    .drawBehind {\r\n                        val strokeWidth = innerStrokeWidth.toPx()\r\n                        val radius = 12.dp.toPx().coerceAtLeast(0f)\r\n                        val adjustedRadius = (radius - strokeWidth / 2f).coerceAtLeast(0f)\r\n                        drawRoundRect(\r\n                            color = Color(0x14000000),\r\n                            topLeft = Offset(strokeWidth / 2f, strokeWidth / 2f),\r\n                            size = Size(size.width - strokeWidth+20, size.height - strokeWidth),\r\n                            cornerRadius = CornerRadius(adjustedRadius, adjustedRadius),\r\n                            style = Stroke(width = strokeWidth)\r\n                        )\r\n                    }\r\n            ) {\r\n            Row(modifier = Modifier.fillMaxSize()) {\r\n                Column(\r\n                    modifier = Modifier\r\n                        .weight(1f)\r\n                        .padding(horizontal = 16.dp, vertical = 8.dp),\r\n//                    verticalArrangement = Arrangement.spacedBy(6.dp)\r\n                ) {\r\n                    Text(\r\n                        text = lessonUi.studentName,\r\n                        style = MaterialTheme.typography.titleSmall,\r\n                        color = MaterialTheme.colorScheme.onSurface,\r\n                        maxLines = 1,\r\n                        overflow = TextOverflow.Ellipsis\r\n                    )\r\n                    lessonUi.secondaryLine?.let { secondaryLine ->\r\n                        Text(\r\n                            text = secondaryLine,\r\n                            style = MaterialTheme.typography.bodySmall,\r\n                            color = MaterialTheme.colorScheme.onSurfaceVariant,\r\n                            maxLines = 1,\r\n                            overflow = TextOverflow.Ellipsis\r\n                        )\r\n                    }\r\n//                    lessonUi.note?.let { note ->\r\n//                        Text(\r\n//                            text = note,\r\n//                            style = MaterialTheme.typography.bodySmall,\r\n//                            color = MaterialTheme.colorScheme.onSurfaceVariant,\r\n//                            maxLines = 1,\r\n//                            overflow = TextOverflow.Ellipsis\r\n//                        )\r\n//                    }\r\n//                    Text(\r\n//                        text = lessonUi.statusDescription,\r\n//                        style = MaterialTheme.typography.bodySmall,\r\n//                        color = MaterialTheme.colorScheme.onSurfaceVariant,\r\n//                        maxLines = 1,\r\n//                        overflow = TextOverflow.Ellipsis\r\n//                    )\r\n                }\r\n                Spacer(modifier = Modifier.width(10.dp))\r\n            }\r\n            }\r\n        }\r\n        Box(\r\n            modifier = Modifier\r\n                .align(Alignment.CenterEnd)\r\n//                .offset(x = 12.dp)\r\n                .fillMaxHeight()\r\n                .width(12.dp)\r\n                .clip(RoundedCornerShape(topEnd = 12.dp, bottomEnd = 12.dp))\r\n                .background(lessonUi.statusColor),\r\n\r\n        )\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun CalendarLesson.statusPresentation(now: ZonedDateTime): StatusChipData =\r\n    statusChipData(paymentStatus, start, end, now)\r\n\r\nprivate data class LessonUi(\r\n    val studentName: String,\r\n    val secondaryLine: String?,\r\n    val note: String?,\r\n    val statusDescription: String,\r\n    val statusColor: Color\r\n)\r\n\r\n@Composable\r\nprivate fun CalendarLesson.toLessonUi(now: ZonedDateTime): LessonUi {\r\n    val status = statusPresentation(now)\r\n    val grade = normalizeGrade(studentGrade)\r\n    val subject = subjectName?.takeIf { it.isNotBlank() }?.trim()\r\n    val secondaryLine = listOfNotNull(grade, subject)\r\n        .takeIf { it.isNotEmpty() }\r\n        ?.joinToString(separator = \" • \")\r\n    val note = lessonNote?.takeIf { it.isNotBlank() }?.trim()\r\n\r\n    return LessonUi(\r\n        studentName = studentName,\r\n        secondaryLine = secondaryLine,\r\n        note = note,\r\n        statusDescription = status.description,\r\n        statusColor = status.background\r\n    )\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt b/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt
--- a/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt	(revision d8fac30411ae443e589c63cdb00fbfb0a6d76483)
+++ b/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt	(date 1761566868276)
@@ -133,6 +133,7 @@
                         origin = LessonCreationOrigin.CALENDAR
                     )
                 )
+
                 is CalendarEvent.OpenLesson -> lessonCardViewModel.open(event.lessonId)
             }
         }
@@ -266,106 +267,107 @@
             )
 
             // Контент занимает остаток экрана и скроллится внутри
-        Box(
-            Modifier
-                .weight(1f)
-                .fillMaxWidth()
-                .clipToBounds()
-                .then(swipeModifier)   // 👈 свайп теперь работает по всему экрану
-        ) {
-            val workdayBounds = remember(uiState.workDayStartMinutes, uiState.workDayEndMinutes) {
-                sanitizeWorkdayBounds(
-                    startMinutes = uiState.workDayStartMinutes,
-                    endMinutes = uiState.workDayEndMinutes
-                )
-            }
+            Box(
+                Modifier
+                    .weight(1f)
+                    .fillMaxWidth()
+                    .clipToBounds()
+                    .then(swipeModifier)   // 👈 свайп теперь работает по всему экрану
+            ) {
+                val workdayBounds =
+                    remember(uiState.workDayStartMinutes, uiState.workDayEndMinutes) {
+                        sanitizeWorkdayBounds(
+                            startMinutes = uiState.workDayStartMinutes,
+                            endMinutes = uiState.workDayEndMinutes
+                        )
+                    }
 
-            AnimatedContent(
-                targetState = anchor,
-                modifier = Modifier.fillMaxSize(),
-                transitionSpec = {
-                    if (direction > 0) {
-                        // вперёд (влево)
-                        (slideInHorizontally(
-                            initialOffsetX = { fullWidth -> fullWidth },
-                            animationSpec = tween(durationMillis = 250)
-                        ) + fadeIn(animationSpec = tween(250))) togetherWith
-                                (slideOutHorizontally(
-                                    targetOffsetX = { fullWidth -> -fullWidth / 2 },
-                                    animationSpec = tween(durationMillis = 250)
-                                ) + fadeOut(animationSpec = tween(250)))
-                    } else {
-                        // назад (вправо)
-                        (slideInHorizontally(
-                            initialOffsetX = { fullWidth -> -fullWidth },
-                            animationSpec = tween(durationMillis = 250)
-                        ) + fadeIn(animationSpec = tween(250))) togetherWith
-                                (slideOutHorizontally(
-                                    targetOffsetX = { fullWidth -> fullWidth / 2 },
-                                    animationSpec = tween(durationMillis = 250)
-                                ) + fadeOut(animationSpec = tween(250)))
-                    }
-                },
-                label = "day-switch"
-            ) { currentDate ->
-                val lessonsForCurrent = remember(
-                    currentDate,
-                    uiState.lessonsByDate,
-                    workdayBounds
-                ) {
-                    uiState.lessonsByDate[currentDate]
-                        .orEmpty()
-                        .filter { lesson ->
-                            lesson.isWithinBounds(currentDate, workdayBounds)
-                        }
-                }
-                when (mode) {
-                    CalendarMode.DAY -> DayTimeline(
-                        date = currentDate,
-                        lessons = lessonsForCurrent,
-                        currentDateTime = uiState.currentDateTime,
-                        workDayStartMinutes = workdayBounds.startMinutes,
-                        workDayEndMinutes = workdayBounds.endMinutes,
-                        onLessonClick = { lesson ->
-                            lessonCardViewModel.open(lesson.id)
-                        },
-                        onEmptySlot = { startTime ->
-                            viewModel.onEmptySlotSelected(
-                                currentDate,
-                                startTime,
-                                DefaultSlotDuration
-                            )
-                        }
-                    )
+                AnimatedContent(
+                    targetState = anchor,
+                    modifier = Modifier.fillMaxSize(),
+                    transitionSpec = {
+                        if (direction > 0) {
+                            // вперёд (влево)
+                            (slideInHorizontally(
+                                initialOffsetX = { fullWidth -> fullWidth },
+                                animationSpec = tween(durationMillis = 250)
+                            ) + fadeIn(animationSpec = tween(250))) togetherWith
+                                    (slideOutHorizontally(
+                                        targetOffsetX = { fullWidth -> -fullWidth / 2 },
+                                        animationSpec = tween(durationMillis = 250)
+                                    ) + fadeOut(animationSpec = tween(250)))
+                        } else {
+                            // назад (вправо)
+                            (slideInHorizontally(
+                                initialOffsetX = { fullWidth -> -fullWidth },
+                                animationSpec = tween(durationMillis = 250)
+                            ) + fadeIn(animationSpec = tween(250))) togetherWith
+                                    (slideOutHorizontally(
+                                        targetOffsetX = { fullWidth -> fullWidth / 2 },
+                                        animationSpec = tween(durationMillis = 250)
+                                    ) + fadeOut(animationSpec = tween(250)))
+                        }
+                    },
+                    label = "day-switch"
+                ) { currentDate ->
+                    val lessonsForCurrent = remember(
+                        currentDate,
+                        uiState.lessonsByDate,
+                        workdayBounds
+                    ) {
+                        uiState.lessonsByDate[currentDate]
+                            .orEmpty()
+                            .filter { lesson ->
+                                lesson.isWithinBounds(currentDate, workdayBounds)
+                            }
+                    }
+                    when (mode) {
+                        CalendarMode.DAY -> DayTimeline(
+                            date = currentDate,
+                            lessons = lessonsForCurrent,
+                            currentDateTime = uiState.currentDateTime,
+                            workDayStartMinutes = workdayBounds.startMinutes,
+                            workDayEndMinutes = workdayBounds.endMinutes,
+                            onLessonClick = { lesson ->
+                                lessonCardViewModel.open(lesson.id)
+                            },
+                            onEmptySlot = { startTime ->
+                                viewModel.onEmptySlotSelected(
+                                    currentDate,
+                                    startTime,
+                                    DefaultSlotDuration
+                                )
+                            }
+                        )
 
-                    CalendarMode.WEEK -> WeekMosaic(
-                        anchor = currentDate,
-                        onOpenDay = { selected ->
-                            direction = when {
-                                selected.isAfter(anchor) -> 1
-                                selected.isBefore(anchor) -> -1
-                                else -> 0
-                            }
-                            viewModel.setMode(CalendarMode.DAY)
-                            viewModel.selectDate(selected)
-                        },
-                        dayDataProvider = { date ->
-                            uiState.lessonsByDate[date]
-                                .orEmpty()
-                                .filter { lesson ->
-                                    lesson.isWithinBounds(date, workdayBounds)
-                                }
-                                .map { it.toLessonBrief() }
-                        },
-                        currentDateTime = uiState.currentDateTime,
-                        onLessonClick = { brief -> lessonCardViewModel.open(brief.id) }
-                    )
+                        CalendarMode.WEEK -> WeekMosaic(
+                            anchor = currentDate,
+                            onOpenDay = { selected ->
+                                direction = when {
+                                    selected.isAfter(anchor) -> 1
+                                    selected.isBefore(anchor) -> -1
+                                    else -> 0
+                                }
+                                viewModel.setMode(CalendarMode.DAY)
+                                viewModel.selectDate(selected)
+                            },
+                            dayDataProvider = { date ->
+                                uiState.lessonsByDate[date]
+                                    .orEmpty()
+                                    .filter { lesson ->
+                                        lesson.isWithinBounds(date, workdayBounds)
+                                    }
+                                    .map { it.toLessonBrief() }
+                            },
+                            currentDateTime = uiState.currentDateTime,
+                            onLessonClick = { brief -> lessonCardViewModel.open(brief.id) }
+                        )
+                    }
                 }
             }
         }
     }
 }
-
 private fun CalendarLesson.toLessonBrief(): LessonBrief {
     return LessonBrief(
         id = id,
