Index: app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.ui\r\n\r\nimport androidx.compose.animation.AnimatedContent\r\nimport androidx.compose.animation.ExperimentalAnimationApi\r\nimport androidx.compose.animation.core.tween\r\nimport androidx.compose.animation.fadeIn\r\nimport androidx.compose.animation.fadeOut\r\nimport androidx.compose.animation.slideInHorizontally\r\nimport androidx.compose.animation.slideOutHorizontally\r\nimport androidx.compose.animation.togetherWith\r\nimport androidx.compose.foundation.Canvas\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.clickable\r\nimport androidx.compose.foundation.gestures.detectHorizontalDragGestures\r\nimport androidx.compose.foundation.gestures.detectTapGestures\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.foundation.lazy.grid.GridCells\r\nimport androidx.compose.foundation.lazy.grid.LazyVerticalGrid\r\nimport androidx.compose.foundation.lazy.grid.items\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.verticalScroll\r\nimport androidx.compose.foundation.shape.CircleShape\r\nimport androidx.compose.foundation.shape.RoundedCornerShape\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.outlined.Add\r\nimport androidx.compose.material.icons.outlined.Settings\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.material3.TabRowDefaults.tabIndicatorOffset\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.runtime.collectAsState\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.draw.clip\r\nimport androidx.compose.ui.draw.clipToBounds\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.ui.input.pointer.pointerInput\r\nimport androidx.compose.ui.layout.wrapContentSize\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.platform.LocalDensity\r\nimport androidx.compose.ui.res.stringResource\r\nimport androidx.compose.ui.text.style.TextAlign\r\nimport androidx.compose.ui.text.style.TextOverflow\r\nimport androidx.compose.ui.unit.Dp\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.hilt.navigation.compose.hiltViewModel\r\nimport android.app.DatePickerDialog\r\nimport com.tutorly.R\r\nimport com.tutorly.ui.CalendarEvent\r\nimport com.tutorly.domain.model.PaymentStatusIcon\r\nimport com.tutorly.models.PaymentStatus\r\nimport com.tutorly.ui.components.LessonBrief\r\nimport com.tutorly.ui.components.StatusChip\r\nimport com.tutorly.ui.components.StatusChipData\r\nimport com.tutorly.ui.components.WeekMosaic\r\nimport com.tutorly.ui.components.statusChipData\r\nimport com.tutorly.ui.theme.extendedColors\r\nimport com.tutorly.ui.lessoncreation.LessonCreationConfig\r\nimport com.tutorly.ui.lessoncreation.LessonCreationOrigin\r\nimport com.tutorly.ui.lessoncreation.LessonCreationSheet\r\nimport com.tutorly.ui.lessoncreation.LessonCreationViewModel\r\nimport com.tutorly.ui.lessoncard.LessonCardSheet\r\nimport com.tutorly.ui.lessoncard.LessonCardViewModel\r\nimport java.time.DayOfWeek\r\nimport java.time.Duration\r\nimport java.time.LocalDate\r\nimport java.time.LocalTime\r\nimport java.time.ZonedDateTime\r\nimport java.time.ZoneId\r\nimport java.time.format.DateTimeFormatter\r\nimport java.util.*\r\nimport kotlin.math.abs\r\nimport kotlin.math.roundToInt\r\n\r\nenum class CalendarMode { DAY, WEEK }\r\n\r\n@OptIn(ExperimentalAnimationApi::class)\r\n@Composable\r\nfun CalendarScreen(\r\n    modifier: Modifier = Modifier,\r\n    onAddStudent: () -> Unit = {},\r\n    onOpenSettings: () -> Unit = {},\r\n    creationViewModel: LessonCreationViewModel,\r\n    viewModel: CalendarViewModel = hiltViewModel()\r\n) {\r\n    val uiState by viewModel.uiState.collectAsState()\r\n    val creationState by creationViewModel.uiState.collectAsState()\r\n    val lessonCardViewModel: LessonCardViewModel = hiltViewModel()\r\n    val lessonCardState by lessonCardViewModel.uiState.collectAsState()\r\n    val snackbarHostState = remember { SnackbarHostState() }\r\n    var direction by remember { mutableStateOf(0) } // -1 назад, +1 вперёд\r\n    val anchor = uiState.anchor\r\n    val mode = uiState.mode\r\n    val zoneId = remember { ZoneId.systemDefault() }\r\n\r\n    LaunchedEffect(mode) {\r\n    }\r\n\r\n    LessonCardSheet(\r\n        state = lessonCardState,\r\n        onDismissRequest = lessonCardViewModel::dismiss,\r\n        onStudentSelect = lessonCardViewModel::onStudentSelected,\r\n        onAddStudent = {\r\n            lessonCardViewModel.dismiss()\r\n            creationViewModel.prepareForStudentCreation()\r\n            onAddStudent()\r\n        },\r\n        onDateSelect = lessonCardViewModel::onDateSelected,\r\n        onTimeSelect = lessonCardViewModel::onTimeSelected,\r\n        onDurationSelect = lessonCardViewModel::onDurationSelected,\r\n        onPriceChange = lessonCardViewModel::onPriceChanged,\r\n        onStatusSelect = lessonCardViewModel::onPaymentStatusSelected,\r\n        onNoteChange = lessonCardViewModel::onNoteChanged,\r\n        onDeleteLesson = lessonCardViewModel::deleteLesson,\r\n        onSnackbarConsumed = lessonCardViewModel::consumeSnackbar\r\n    )\r\n\r\n    LaunchedEffect(viewModel) {\r\n        viewModel.events.collect { event ->\r\n            when (event) {\r\n                is CalendarEvent.CreateLesson -> creationViewModel.start(\r\n                    LessonCreationConfig(\r\n                        start = event.start,\r\n                        duration = event.duration,\r\n                        studentId = event.studentId,\r\n                        zoneId = event.start.zone,\r\n                        origin = LessonCreationOrigin.CALENDAR\r\n                    )\r\n                )\r\n                is CalendarEvent.OpenLesson -> lessonCardViewModel.open(event.lessonId)\r\n            }\r\n        }\r\n    }\r\n\r\n    LaunchedEffect(creationState.snackbarMessage) {\r\n        creationState.snackbarMessage?.let { message ->\r\n            snackbarHostState.showSnackbar(message)\r\n            creationViewModel.consumeSnackbar()\r\n        }\r\n    }\r\n\r\n    LessonCreationSheet(\r\n        state = creationState,\r\n        onDismiss = { creationViewModel.dismiss() },\r\n        onStudentQueryChange = creationViewModel::onStudentQueryChange,\r\n        onStudentGradeChange = creationViewModel::onStudentGradeChanged,\r\n        onStudentSelect = creationViewModel::onStudentSelected,\r\n        onSubjectInputChange = creationViewModel::onSubjectInputChanged,\r\n        onSubjectSelect = creationViewModel::onSubjectSelected,\r\n        onSubjectSuggestionToggle = creationViewModel::onSubjectSuggestionToggled,\r\n        onSubjectChipRemove = creationViewModel::onSubjectChipRemoved,\r\n        onDateSelect = creationViewModel::onDateSelected,\r\n        onTimeSelect = creationViewModel::onTimeSelected,\r\n        onDurationChange = creationViewModel::onDurationChanged,\r\n        onPriceChange = creationViewModel::onPriceChanged,\r\n        onNoteChange = creationViewModel::onNoteChanged,\r\n        onSubmit = creationViewModel::submit,\r\n        onConfirmConflict = creationViewModel::confirmConflict,\r\n        onDismissConflict = creationViewModel::dismissConflict\r\n    )\r\n\r\n    val prevPeriod = {\r\n        direction = -1\r\n        viewModel.goToPreviousPeriod()\r\n    }\r\n    val nextPeriod = {\r\n        direction = +1\r\n        viewModel.goToNextPeriod()\r\n    }\r\n\r\n    val swipeModifier = Modifier.pointerInput(mode) {\r\n        val threshold = 48.dp.toPx()\r\n        var totalDrag = 0f\r\n        var handled = false\r\n        detectHorizontalDragGestures(\r\n            onDragStart = {\r\n                totalDrag = 0f\r\n                handled = false\r\n            },\r\n            onDragEnd = {\r\n                totalDrag = 0f\r\n                handled = false\r\n            },\r\n            onDragCancel = {\r\n                totalDrag = 0f\r\n                handled = false\r\n            },\r\n            onHorizontalDrag = { change, dragAmount ->\r\n                if (handled) return@detectHorizontalDragGestures\r\n\r\n                totalDrag += dragAmount\r\n                if (abs(totalDrag) > threshold) {\r\n                    if (totalDrag < 0) nextPeriod() else prevPeriod()\r\n                    handled = true\r\n                    change.consume()\r\n                }\r\n            }\r\n        )\r\n    }\r\n\r\n    Scaffold(\r\n        modifier = modifier,\r\n        topBar = {\r\n            CalendarTopBar(\r\n                anchor = anchor,\r\n                currentDateTime = uiState.currentDateTime,\r\n                onSelectDate = { selected ->\r\n                    direction = when {\r\n                        selected.isAfter(anchor) -> 1\r\n                        selected.isBefore(anchor) -> -1\r\n                        else -> 0\r\n                    }\r\n                    viewModel.selectDate(selected)\r\n                },\r\n                onOpenSettings = onOpenSettings\r\n            )\r\n        },\r\n        snackbarHost = { SnackbarHost(snackbarHostState) },\r\n        floatingActionButton = {\r\n            FloatingActionButton(\r\n                onClick = {\r\n                    val start = uiState.currentDateTime\r\n                    creationViewModel.start(\r\n                        LessonCreationConfig(\r\n                            start = start,\r\n                            zoneId = uiState.zoneId,\r\n                            origin = LessonCreationOrigin.CALENDAR\r\n                        )\r\n                    )\r\n                },\r\n                containerColor = MaterialTheme.extendedColors.accent,\r\n                contentColor = MaterialTheme.colorScheme.onPrimary\r\n            ) {\r\n                Icon(\r\n                    imageVector = Icons.Outlined.Add,\r\n                    contentDescription = stringResource(id = R.string.lesson_create_title)\r\n                )\r\n            }\r\n        },\r\n        containerColor = Color.Transparent\r\n    ) { padding ->\r\n        Column(\r\n            Modifier\r\n                .fillMaxSize()\r\n                .padding(padding)\r\n        ) {\r\n        // Хедер: тут же свайп (чтобы не конфликтовал со скроллом списка)\r\n        PlanScreenHeader(\r\n            mode = mode,\r\n            onSwipeLeft = nextPeriod,\r\n            onSwipeRight = prevPeriod,\r\n            onSelectMode = { newMode ->\r\n                direction = 0\r\n                viewModel.setMode(newMode)\r\n            }\r\n        )\r\n\r\n        // Контент занимает остаток экрана и скроллится внутри\r\n        Box(\r\n            Modifier\r\n                .weight(1f)\r\n                .fillMaxWidth()\r\n                .clipToBounds()\r\n                .then(swipeModifier)   // \uD83D\uDC48 свайп теперь работает по всему экрану\r\n        ) {\r\n            AnimatedContent(\r\n                targetState = anchor,\r\n                modifier = Modifier.fillMaxSize(),\r\n                transitionSpec = {\r\n                    if (direction > 0) {\r\n                        // вперёд (влево)\r\n                        (slideInHorizontally(\r\n                            initialOffsetX = { fullWidth -> fullWidth },\r\n                            animationSpec = tween(durationMillis = 250)\r\n                        ) + fadeIn(animationSpec = tween(250))) togetherWith\r\n                                (slideOutHorizontally(\r\n                                    targetOffsetX = { fullWidth -> -fullWidth / 2 },\r\n                                    animationSpec = tween(durationMillis = 250)\r\n                                ) + fadeOut(animationSpec = tween(250)))\r\n                    } else {\r\n                        // назад (вправо)\r\n                        (slideInHorizontally(\r\n                            initialOffsetX = { fullWidth -> -fullWidth },\r\n                            animationSpec = tween(durationMillis = 250)\r\n                        ) + fadeIn(animationSpec = tween(250))) togetherWith\r\n                                (slideOutHorizontally(\r\n                                    targetOffsetX = { fullWidth -> fullWidth / 2 },\r\n                                    animationSpec = tween(durationMillis = 250)\r\n                                ) + fadeOut(animationSpec = tween(250)))\r\n                    }\r\n                }\r\n                ,\r\n                label = \"day-switch\"\r\n            ) { currentDate ->\r\n                val lessonsForCurrent = remember(currentDate, uiState.lessonsByDate) {\r\n                    uiState.lessonsByDate[currentDate].orEmpty()\r\n                }\r\n                when (mode) {\r\n                    CalendarMode.DAY -> DayTimeline(\r\n                        date = currentDate,\r\n                        lessons = lessonsForCurrent,\r\n                        currentDateTime = uiState.currentDateTime,\r\n                        workDayStartMinutes = uiState.workDayStartMinutes,\r\n                        workDayEndMinutes = uiState.workDayEndMinutes,\r\n                        onLessonClick = { lesson ->\r\n                            lessonCardViewModel.open(lesson.id)\r\n                        },\r\n                        onEmptySlot = { startTime ->\r\n                            viewModel.onEmptySlotSelected(currentDate, startTime, DefaultSlotDuration)\r\n                        }\r\n                    )\r\n                    CalendarMode.WEEK -> WeekMosaic(\r\n                        anchor = currentDate,\r\n                        onOpenDay = { selected ->\r\n                            direction = when {\r\n                                selected.isAfter(anchor) -> 1\r\n                                selected.isBefore(anchor) -> -1\r\n                                else -> 0\r\n                            }\r\n                            viewModel.setMode(CalendarMode.DAY)\r\n                            viewModel.selectDate(selected)\r\n                        },\r\n                        dayDataProvider = { date ->\r\n                            uiState.lessonsByDate[date].orEmpty().map { it.toLessonBrief() }\r\n                        },\r\n                        currentDateTime = uiState.currentDateTime,\r\n                        onLessonClick = { brief -> lessonCardViewModel.open(brief.id) }\r\n                    )\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n    }\r\n}\r\n\r\nprivate fun CalendarLesson.toLessonBrief(): LessonBrief {\r\n    return LessonBrief(\r\n        id = id,\r\n        start = start,\r\n        end = end,\r\n        student = studentName,\r\n        grade = studentGrade,\r\n        subjectName = subjectName,\r\n        subjectColorArgb = subjectColorArgb,\r\n        paymentStatus = paymentStatus\r\n    )\r\n}\r\n\r\n\r\n/* ----------------------------- TOP BAR ----------------------------------- */\r\n\r\n@Composable\r\nprivate fun CalendarTopBar(\r\n    anchor: LocalDate,\r\n    currentDateTime: ZonedDateTime,\r\n    onSelectDate: (LocalDate) -> Unit,\r\n    onOpenSettings: () -> Unit\r\n) {\r\n    val locale = remember { Locale(\"ru\") }\r\n    val monthFormatter = remember(locale) { DateTimeFormatter.ofPattern(\"LLLL yyyy\", locale) }\r\n    val monthLabel = remember(anchor, locale) {\r\n        val raw = monthFormatter.format(anchor)\r\n        raw.replaceFirstChar { if (it.isLowerCase()) it.titlecase(locale) else it.toString() }\r\n    }\r\n    var showDatePicker by remember { mutableStateOf(false) }\r\n    val context = LocalContext.current\r\n\r\n    val weekStart = remember(anchor) { anchor.with(DayOfWeek.MONDAY) }\r\n    val weekDays = remember(weekStart) { (0 until 7).map { weekStart.plusDays(it.toLong()) } }\r\n    val today = remember(currentDateTime) { currentDateTime.toLocalDate() }\r\n\r\n    val backgroundColor = Color(0xFFFEFEFE)\r\n    Box(\r\n        modifier = Modifier\r\n            .fillMaxWidth()\r\n            .background(backgroundColor)\r\n    ) {\r\n        Column(\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .statusBarsPadding(),\r\n            horizontalAlignment = Alignment.CenterHorizontally\r\n        ) {\r\n            Box(\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .padding(horizontal = 16.dp, vertical = 12.dp)\r\n            ) {\r\n                Text(\r\n                    text = monthLabel,\r\n                    style = MaterialTheme.typography.titleLarge,\r\n                    color = MaterialTheme.colorScheme.onSurface,\r\n                    modifier = Modifier\r\n                        .align(Alignment.Center)\r\n                        .padding(horizontal = 48.dp)\r\n                        .clickable { showDatePicker = true },\r\n                    textAlign = TextAlign.Center,\r\n                    maxLines = 1,\r\n                    overflow = TextOverflow.Ellipsis\r\n                )\r\n                IconButton(\r\n                    onClick = onOpenSettings,\r\n                    modifier = Modifier.align(Alignment.CenterEnd),\r\n                    colors = IconButtonDefaults.iconButtonColors(\r\n                        contentColor = Color(0xFF2A2F63)\r\n                    )\r\n                ) {\r\n                    Icon(\r\n                        imageVector = Icons.Outlined.Settings,\r\n                        contentDescription = stringResource(id = R.string.settings_title)\r\n                    )\r\n                }\r\n            }\r\n\r\n            Row(\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .padding(horizontal = 16.dp)\r\n                    .padding(bottom = 6.dp),\r\n                horizontalArrangement = Arrangement.SpaceBetween,\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                weekDays.forEach { day ->\r\n                    WeekDayCell(\r\n                        modifier = Modifier.weight(1f),\r\n                        date = day,\r\n                        isSelected = day == anchor,\r\n                        isToday = day == today,\r\n                        locale = locale,\r\n                        onClick = { onSelectDate(day) }\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (showDatePicker) {\r\n        DisposableEffect(anchor) {\r\n            val picker = DatePickerDialog(\r\n                context,\r\n                { _, year, month, dayOfMonth ->\r\n                    showDatePicker = false\r\n                    onSelectDate(LocalDate.of(year, month + 1, dayOfMonth))\r\n                },\r\n                anchor.year,\r\n                anchor.monthValue - 1,\r\n                anchor.dayOfMonth\r\n            )\r\n            picker.setOnDismissListener { showDatePicker = false }\r\n            picker.show()\r\n            onDispose {\r\n                picker.setOnDismissListener(null)\r\n                if (picker.isShowing) {\r\n                    picker.dismiss()\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun CalendarModeToggle(\r\n    selected: CalendarMode,\r\n    onSelect: (CalendarMode) -> Unit,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    val options = remember { listOf(CalendarMode.DAY, CalendarMode.WEEK) }\r\n    val selectedIndex = options.indexOf(selected).coerceAtLeast(0)\r\n    val accent = MaterialTheme.extendedColors.accent\r\n    val inactiveColor = Color(0xFFB9BCC7)\r\n    TabRow(\r\n        selectedTabIndex = selectedIndex,\r\n        modifier = modifier,\r\n        containerColor = Color(0xFFFEFEFE),\r\n        contentColor = MaterialTheme.colorScheme.onSurface,\r\n        divider = {},\r\n        indicator = { tabPositions ->\r\n            if (selectedIndex in tabPositions.indices) {\r\n                val position = tabPositions[selectedIndex]\r\n                Box(\r\n                    modifier = Modifier\r\n                        .fillMaxWidth()\r\n                        .wrapContentSize(Alignment.BottomStart)\r\n                ) {\r\n                    Box(\r\n                        modifier = Modifier\r\n                            .tabIndicatorOffset(position)\r\n                            .padding(horizontal = 28.dp)\r\n                            .height(3.dp)\r\n                            .clip(RoundedCornerShape(topStart = 3.dp, topEnd = 3.dp))\r\n                            .background(accent)\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    ) {\r\n        options.forEachIndexed { index, option ->\r\n            val labelRes = if (option == CalendarMode.DAY) {\r\n                R.string.calendar_mode_day\r\n            } else {\r\n                R.string.calendar_mode_week\r\n            }\r\n            val isSelected = index == selectedIndex\r\n            Tab(\r\n                selected = isSelected,\r\n                onClick = {\r\n                    if (!isSelected) onSelect(option)\r\n                }\r\n            ) {\r\n                Box(\r\n                    modifier = Modifier\r\n                        .fillMaxWidth()\r\n                        .padding(vertical = 12.dp),\r\n                    contentAlignment = Alignment.Center\r\n                ) {\r\n                    Text(\r\n                        text = stringResource(id = labelRes),\r\n                        style = MaterialTheme.typography.titleMedium,\r\n                        color = if (isSelected) {\r\n                            MaterialTheme.colorScheme.onSurface\r\n                        } else {\r\n                            inactiveColor\r\n                        }\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/* ----------------------------- HEADER ----------------------------------- */\r\n\r\n@Composable\r\nfun PlanScreenHeader(\r\n    mode: CalendarMode,\r\n    onSwipeLeft: () -> Unit,\r\n    onSwipeRight: () -> Unit,\r\n    onSelectMode: (CalendarMode) -> Unit\r\n) {\r\n    val headerBackground = Color(0xFFFEFEFE)\r\n    Column(\r\n        modifier = Modifier\r\n            .fillMaxWidth()\r\n            .clip(RoundedCornerShape(bottomStart = 32.dp, bottomEnd = 32.dp))\r\n            .background(headerBackground)\r\n            .padding(top = 6.dp, bottom = 12.dp)\r\n            .pointerInput(mode) {\r\n                val threshold = 48.dp.toPx()\r\n                var totalDrag = 0f\r\n                var handled = false\r\n                detectHorizontalDragGestures(\r\n                    onDragStart = {\r\n                        totalDrag = 0f\r\n                        handled = false\r\n                    },\r\n                    onDragEnd = {\r\n                        totalDrag = 0f\r\n                        handled = false\r\n                    },\r\n                    onDragCancel = {\r\n                        totalDrag = 0f\r\n                        handled = false\r\n                    },\r\n                    onHorizontalDrag = { change, dragAmount ->\r\n                        if (handled) return@detectHorizontalDragGestures\r\n\r\n                        totalDrag += dragAmount\r\n                        if (abs(totalDrag) > threshold) {\r\n                            if (totalDrag < 0) onSwipeLeft() else onSwipeRight()\r\n                            handled = true\r\n                            change.consume()\r\n                        }\r\n                    }\r\n                )\r\n            }\r\n    ) {\r\n        CalendarModeToggle(\r\n            selected = mode,\r\n            onSelect = onSelectMode,\r\n            modifier = Modifier.fillMaxWidth()\r\n        )\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun WeekDayCell(\r\n    modifier: Modifier = Modifier,\r\n    date: LocalDate,\r\n    isSelected: Boolean,\r\n    isToday: Boolean,\r\n    locale: Locale,\r\n    onClick: () -> Unit\r\n) {\r\n    val accent = MaterialTheme.extendedColors.accent\r\n    val label = remember(date, locale) {\r\n        date.dayOfWeek.getDisplayName(java.time.format.TextStyle.SHORT, locale)\r\n            .replaceFirstChar { if (it.isLowerCase()) it.titlecase(locale) else it.toString() }\r\n    }\r\n    val number = remember(date) { date.dayOfMonth.toString() }\r\n    val circleColor = if (isSelected) accent else Color.Transparent\r\n    val numberColor = if (isSelected) Color.White else MaterialTheme.colorScheme.onSurface\r\n    val labelColor = Color(0xFFB9BCC7)\r\n\r\n    Column(\r\n        modifier = modifier\r\n            .widthIn(min = 44.dp)\r\n            .clip(RoundedCornerShape(18.dp))\r\n            .clickable(onClick = onClick)\r\n            .padding(vertical = 6.dp, horizontal = 4.dp),\r\n        horizontalAlignment = Alignment.CenterHorizontally,\r\n        verticalArrangement = Arrangement.spacedBy(8.dp, Alignment.CenterVertically)\r\n    ) {\r\n        Text(\r\n            text = label,\r\n            style = MaterialTheme.typography.labelMedium,\r\n            color = labelColor\r\n        )\r\n        Box(\r\n            modifier = Modifier\r\n                .size(42.dp)\r\n                .clip(CircleShape)\r\n                .background(circleColor),\r\n            contentAlignment = Alignment.Center\r\n        ) {\r\n            Text(\r\n                text = number,\r\n                style = MaterialTheme.typography.titleMedium,\r\n                color = numberColor\r\n            )\r\n        }\r\n        if (isToday && !isSelected) {\r\n            Box(\r\n                modifier = Modifier\r\n                    .size(6.dp)\r\n                    .clip(CircleShape)\r\n                    .background(accent)\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n/* --------------------------- DAY TIMELINE -------------------------------- */\r\n\r\nprivate val LabelWidth = 64.dp\r\nprivate val HourHeight = 80.dp\r\nprivate val DefaultSlotDuration: Duration = Duration.ofMinutes(60)\r\nprivate const val MinutesPerHour: Int = 60\r\nprivate const val LAST_TIMELINE_MINUTE: Int = 23 * MinutesPerHour + 30\r\nprivate const val SlotIncrementMinutes: Int = 30\r\nprivate const val MAX_START_MINUTE: Int = LAST_TIMELINE_MINUTE - SlotIncrementMinutes\r\nprivate const val MAX_END_MINUTE: Int = LAST_TIMELINE_MINUTE\r\n\r\n@Composable\r\nprivate fun DayTimeline(\r\n    date: LocalDate,\r\n    lessons: List<CalendarLesson>,\r\n    currentDateTime: ZonedDateTime,\r\n    workDayStartMinutes: Int,\r\n    workDayEndMinutes: Int,\r\n    onLessonClick: (CalendarLesson) -> Unit,\r\n    onEmptySlot: (LocalTime) -> Unit\r\n) {\r\n    val dayLessons = remember(date, lessons) { lessons }\r\n    val isToday = remember(date, currentDateTime) { currentDateTime.toLocalDate() == date }\r\n    val startMinutes = remember(workDayStartMinutes) {\r\n        workDayStartMinutes.coerceIn(0, MAX_START_MINUTE)\r\n    }\r\n    val endMinutes = remember(workDayEndMinutes, startMinutes) {\r\n        workDayEndMinutes.coerceIn(startMinutes + SlotIncrementMinutes, MAX_END_MINUTE)\r\n    }\r\n    val totalMinutes = remember(startMinutes, endMinutes) {\r\n        (endMinutes - startMinutes).coerceAtLeast(SlotIncrementMinutes)\r\n    }\r\n    val minuteHeight = remember { HourHeight / MinutesPerHour }\r\n    val totalHeight = remember(totalMinutes) { minuteHeight * totalMinutes.toFloat() }\r\n\r\n    val scroll = rememberScrollState()\r\n    val density = LocalDensity.current\r\n    val minuteHeightPx = remember(density) { with(density) { minuteHeight.toPx() } }\r\n    val labelWidthPx = remember(density) { with(density) { LabelWidth.toPx() } }\r\n    val cardInsetPx = remember(density) { with(density) { 16.dp.toPx() } }\r\n    val totalHeightPx = remember(totalHeight, density) { with(density) { totalHeight.toPx() } }\r\n    val nowMinutesFromStart = remember(isToday, currentDateTime, startMinutes, totalMinutes) {\r\n        if (!isToday) {\r\n            null\r\n        } else {\r\n            val currentMinutes = currentDateTime.hour * MinutesPerHour + currentDateTime.minute\r\n            val within = currentMinutes - startMinutes\r\n            within.takeIf { it in 0..totalMinutes }\r\n        }\r\n    }\r\n    val hourMarks = remember(startMinutes, endMinutes) {\r\n        buildList {\r\n            add(startMinutes)\r\n            var next = ((startMinutes / MinutesPerHour) + 1) * MinutesPerHour\r\n            while (next < endMinutes) {\r\n                add(next)\r\n                next += MinutesPerHour\r\n            }\r\n            add(endMinutes)\r\n        }.distinct()\r\n    }\r\n    val labelMinutes = remember(startMinutes, endMinutes) {\r\n        buildList {\r\n            add(startMinutes)\r\n            var next = ((startMinutes / MinutesPerHour) + 1) * MinutesPerHour\r\n            while (next < endMinutes) {\r\n                add(next)\r\n                next += MinutesPerHour\r\n            }\r\n        }\r\n    }\r\n    val lessonRegions = remember(dayLessons, startMinutes, minuteHeightPx, labelWidthPx, cardInsetPx) {\r\n        val baseMin = startMinutes\r\n        dayLessons.map { lesson ->\r\n            val startTime = lesson.start.toLocalTime()\r\n            val lessonStart = startTime.hour * MinutesPerHour + startTime.minute\r\n            val offsetMinutes = (lessonStart - baseMin).coerceAtLeast(0)\r\n            val durationMinutes = lesson.duration.toMinutes().coerceAtLeast(SlotIncrementMinutes.toLong())\r\n            val topPx = offsetMinutes * minuteHeightPx\r\n            val heightPx = durationMinutes.toFloat() * minuteHeightPx\r\n            TimelineLessonRegion(\r\n                topPx = topPx,\r\n                bottomPx = topPx + heightPx,\r\n                leftPx = labelWidthPx + cardInsetPx\r\n            )\r\n        }\r\n    }\r\n\r\n    Box(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .background(MaterialTheme.colorScheme.surfaceVariant)\r\n            .padding(horizontal = 16.dp, vertical = 12.dp)\r\n    ) {\r\n        Card(\r\n            modifier = Modifier.fillMaxSize(),\r\n            shape = RoundedCornerShape(28.dp),\r\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface),\r\n            elevation = CardDefaults.cardElevation(defaultElevation = 6.dp)\r\n        ) {\r\n            Column(\r\n                modifier = Modifier\r\n                    .fillMaxSize()\r\n                    .verticalScroll(scroll)\r\n            ) {\r\n                Box(\r\n                    Modifier\r\n                        .fillMaxWidth()\r\n                        .height(totalHeight)\r\n                        .padding(horizontal = 16.dp, vertical = 12.dp)\r\n                        .pointerInput(dayLessons, startMinutes, endMinutes, lessonRegions) {\r\n                            detectTapGestures { offset ->\r\n                                if (offset.x < labelWidthPx) return@detectTapGestures\r\n                                if (lessonRegions.any { region ->\r\n                                        offset.x >= region.leftPx && offset.y in region.topPx..region.bottomPx\r\n                                    }\r\n                                ) {\r\n                                    return@detectTapGestures\r\n                                }\r\n\r\n                                val clampedY = offset.y.coerceIn(0f, totalHeightPx)\r\n                                val minutesWithin = (clampedY / minuteHeightPx).roundToInt()\r\n                                val candidate = startMinutes + minutesWithin\r\n                                val maxSelectable = (endMinutes - SlotIncrementMinutes).coerceAtLeast(startMinutes)\r\n                                val normalized = candidate.coerceIn(startMinutes, maxSelectable)\r\n                                val slots = (normalized - startMinutes) / SlotIncrementMinutes\r\n                                val rounded = startMinutes + slots * SlotIncrementMinutes\r\n                                val hour = rounded / MinutesPerHour\r\n                                val minute = rounded % MinutesPerHour\r\n                                onEmptySlot(LocalTime.of(hour, minute))\r\n                            }\r\n                        }\r\n                ) {\r\n                    val gridLineColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.06f)\r\n                    val accent = MaterialTheme.extendedColors.accent\r\n                    Canvas(Modifier.matchParentSize()) {\r\n                        val leftPad = LabelWidth.toPx()\r\n                        val spineW = 2.dp.toPx()\r\n                        hourMarks.forEach { minute ->\r\n                            val y = (minute - startMinutes) * minuteHeightPx\r\n                            drawLine(\r\n                                color = gridLineColor,\r\n                                start = androidx.compose.ui.geometry.Offset(leftPad, y),\r\n                                end = androidx.compose.ui.geometry.Offset(size.width, y),\r\n                                strokeWidth = 1.dp.toPx()\r\n                            )\r\n                        }\r\n                        drawRect(\r\n                            color = accent,\r\n                            topLeft = androidx.compose.ui.geometry.Offset(leftPad - spineW / 2f, 0f),\r\n                            size = androidx.compose.ui.geometry.Size(spineW, size.height)\r\n                        )\r\n                        nowMinutesFromStart?.let { minutes ->\r\n                            val y = minutes * minuteHeightPx\r\n                            drawLine(\r\n                                color = accent,\r\n                                start = androidx.compose.ui.geometry.Offset(leftPad, y),\r\n                                end = androidx.compose.ui.geometry.Offset(size.width, y),\r\n                                strokeWidth = 2.dp.toPx()\r\n                            )\r\n                        }\r\n                    }\r\n\r\n                    dayLessons.forEach { lesson ->\r\n                        LessonBlock(\r\n                            lesson = lesson,\r\n                            baseMinutes = startMinutes,\r\n                            minuteHeight = minuteHeight,\r\n                            now = currentDateTime,\r\n                            onLessonClick = onLessonClick\r\n                        )\r\n                    }\r\n\r\n                    Box(\r\n                        Modifier\r\n                            .fillMaxHeight()\r\n                            .width(LabelWidth)\r\n                    ) {\r\n                        labelMinutes.forEach { minute ->\r\n                            val label = \"%02d:%02d\".format(minute / MinutesPerHour, minute % MinutesPerHour)\r\n                            Text(\r\n                                text = label,\r\n                                style = MaterialTheme.typography.labelLarge,\r\n                                color = MaterialTheme.colorScheme.onSurfaceVariant,\r\n                                modifier = Modifier\r\n                                    .align(Alignment.TopStart)\r\n                                    .offset(y = minuteHeight * (minute - startMinutes).toFloat())\r\n                            )\r\n                        }\r\n                    }\r\n                }\r\n\r\n                Spacer(modifier = Modifier.height(24.dp))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate data class TimelineLessonRegion(\r\n    val topPx: Float,\r\n    val bottomPx: Float,\r\n    val leftPx: Float\r\n)\r\n\r\n@Composable\r\nprivate fun LessonBlock(\r\n    lesson: CalendarLesson,\r\n    baseMinutes: Int,\r\n    minuteHeight: Dp,\r\n    now: ZonedDateTime,\r\n    onLessonClick: (CalendarLesson) -> Unit\r\n) {\r\n    val startTime = lesson.start.toLocalTime()\r\n    val startMin = startTime.hour * MinutesPerHour + startTime.minute\r\n    val offsetMinutes = (startMin - baseMinutes).coerceAtLeast(0)\r\n    val durationMinutes = lesson.duration.toMinutes().coerceAtLeast(SlotIncrementMinutes.toLong())\r\n\r\n    val top = minuteHeight * offsetMinutes.toFloat()\r\n    val height = minuteHeight * durationMinutes.toInt().toFloat()\r\n\r\n    val statusInfo = lesson.statusPresentation(now)\r\n    val subjectColor = lesson.subjectColorArgb?.let { Color(it) } ?: MaterialTheme.extendedColors.accent\r\n    val statusColor = statusInfo.background\r\n    val timeFormatter = remember { DateTimeFormatter.ofPattern(\"HH:mm\") }\r\n    val timeRange = remember(lesson.start, lesson.end) {\r\n        val startLabel = timeFormatter.format(lesson.start.toLocalTime())\r\n        val endLabel = timeFormatter.format(lesson.end.toLocalTime())\r\n        \"$startLabel – $endLabel\"\r\n    }\r\n    val secondaryLine = remember(lesson.studentGrade, lesson.subjectName) {\r\n        val grade = normalizeGrade(lesson.studentGrade)\r\n        val subject = lesson.subjectName?.takeIf { it.isNotBlank() }?.trim()\r\n        listOfNotNull(grade, subject)\r\n            .takeIf { it.isNotEmpty() }\r\n            ?.joinToString(separator = \" • \")\r\n    }\r\n\r\n    Box(\r\n        Modifier\r\n            .fillMaxWidth()\r\n            .offset(y = top)\r\n            .height(height)\r\n            .padding(start = LabelWidth + 16.dp, end = 16.dp)\r\n    ) {\r\n        Card(\r\n            onClick = { onLessonClick(lesson) },\r\n            shape = RoundedCornerShape(24.dp),\r\n            colors = CardDefaults.cardColors(\r\n                containerColor = MaterialTheme.colorScheme.surfaceVariant\r\n            ),\r\n            elevation = CardDefaults.cardElevation(\r\n                defaultElevation = 2.dp,\r\n                focusedElevation = 3.dp,\r\n                hoveredElevation = 3.dp,\r\n                pressedElevation = 2.dp,\r\n                draggedElevation = 4.dp,\r\n                disabledElevation = 0.dp\r\n            ),\r\n            modifier = Modifier.fillMaxSize()\r\n        ) {\r\n            Row(modifier = Modifier.fillMaxSize()) {\r\n                Box(\r\n                    modifier = Modifier\r\n                        .fillMaxHeight()\r\n                        .width(6.dp)\r\n                        .clip(RoundedCornerShape(topStart = 24.dp, bottomStart = 24.dp))\r\n                        .background(subjectColor)\r\n                )\r\n                Column(\r\n                    modifier = Modifier\r\n                        .weight(1f)\r\n                        .padding(horizontal = 16.dp, vertical = 14.dp),\r\n                    verticalArrangement = Arrangement.spacedBy(8.dp)\r\n                ) {\r\n                    Row(\r\n                        modifier = Modifier.fillMaxWidth(),\r\n                        horizontalArrangement = Arrangement.SpaceBetween,\r\n                        verticalAlignment = Alignment.CenterVertically\r\n                    ) {\r\n                        Text(\r\n                            text = timeRange,\r\n                            style = MaterialTheme.typography.labelLarge,\r\n                            color = MaterialTheme.colorScheme.onSurfaceVariant\r\n                        )\r\n                        StatusChip(data = statusInfo)\r\n                    }\r\n                    Text(\r\n                        text = lesson.studentName,\r\n                        style = MaterialTheme.typography.titleMedium,\r\n                        maxLines = 1,\r\n                        overflow = TextOverflow.Ellipsis\r\n                    )\r\n                    if (!secondaryLine.isNullOrBlank()) {\r\n                        Text(\r\n                            text = secondaryLine,\r\n                            style = MaterialTheme.typography.bodyMedium,\r\n                            color = MaterialTheme.colorScheme.onSurfaceVariant,\r\n                            maxLines = 1,\r\n                            overflow = TextOverflow.Ellipsis\r\n                        )\r\n                    }\r\n                    lesson.lessonNote?.takeIf { it.isNotBlank() }?.let { note ->\r\n                        Text(\r\n                            text = note.trim(),\r\n                            style = MaterialTheme.typography.bodySmall,\r\n                            color = MaterialTheme.colorScheme.onSurfaceVariant,\r\n                            maxLines = 1,\r\n                            overflow = TextOverflow.Ellipsis\r\n                        )\r\n                    }\r\n                }\r\n                Box(\r\n                    modifier = Modifier\r\n                        .fillMaxHeight()\r\n                        .width(6.dp)\r\n                        .clip(RoundedCornerShape(topEnd = 24.dp, bottomEnd = 24.dp))\r\n                        .background(statusColor)\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun CalendarLesson.statusPresentation(now: ZonedDateTime): StatusChipData =\r\n    statusChipData(paymentStatus, start, end, now)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt b/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt
--- a/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt	(revision 415fe506c4006cec2c40a1b41c1d439650486410)
+++ b/app/src/main/java/com/tutorly/ui/screens/CalendarScreen.kt	(date 1761075720181)
@@ -34,7 +34,6 @@
 import androidx.compose.ui.draw.clipToBounds
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.input.pointer.pointerInput
-import androidx.compose.ui.layout.wrapContentSize
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.LocalDensity
 import androidx.compose.ui.res.stringResource
@@ -60,6 +59,7 @@
 import com.tutorly.ui.lessoncreation.LessonCreationViewModel
 import com.tutorly.ui.lessoncard.LessonCardSheet
 import com.tutorly.ui.lessoncard.LessonCardViewModel
+import com.tutorly.ui.screens.normalizeGrade
 import java.time.DayOfWeek
 import java.time.Duration
 import java.time.LocalDate
Index: app/src/main/java/com/tutorly/ui/screens/StudentEditorForm.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.ui.screens\r\n\r\nimport androidx.compose.foundation.ExperimentalLayoutApi\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.interaction.MutableInteractionSource\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.foundation.rememberScrollState\r\nimport androidx.compose.foundation.shape.CircleShape\r\nimport androidx.compose.foundation.text.BasicTextField\r\nimport androidx.compose.foundation.text.KeyboardActions\r\nimport androidx.compose.foundation.text.KeyboardOptions\r\nimport androidx.compose.foundation.verticalScroll\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.AlternateEmail\r\nimport androidx.compose.material.icons.filled.ArrowDropDown\r\nimport androidx.compose.material.icons.filled.ArrowDropUp\r\nimport androidx.compose.material.icons.filled.Book\r\nimport androidx.compose.material.icons.filled.Check\r\nimport androidx.compose.material.icons.filled.Description\r\nimport androidx.compose.material.icons.filled.Message\r\nimport androidx.compose.material.icons.filled.Person\r\nimport androidx.compose.material.icons.filled.Phone\r\nimport androidx.compose.material.icons.filled.School\r\nimport androidx.compose.material.icons.filled.Close\r\nimport androidx.compose.material.icons.outlined.CurrencyRuble\r\nimport androidx.compose.material3.DropdownMenu\r\nimport androidx.compose.material3.DropdownMenuItem\r\nimport androidx.compose.material3.ExperimentalMaterial3Api\r\nimport androidx.compose.material3.FilterChip\r\nimport androidx.compose.material3.FilterChipDefaults\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.IconButton\r\nimport androidx.compose.material3.MaterialTheme\r\nimport androidx.compose.material3.OutlinedTextField\r\nimport androidx.compose.material3.OutlinedTextFieldDefaults\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TextButton\r\nimport androidx.compose.material3.TextFieldColors\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.runtime.saveable.rememberSaveable\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.focus.FocusRequester\r\nimport androidx.compose.ui.focus.focusRequester\r\nimport androidx.compose.ui.focus.onFocusChanged\r\nimport androidx.compose.ui.graphics.Color\r\nimport androidx.compose.ui.graphics.SolidColor\r\nimport androidx.compose.ui.layout.onGloballyPositioned\r\nimport androidx.compose.ui.platform.LocalDensity\r\nimport androidx.compose.ui.platform.LocalTextStyle\r\nimport androidx.compose.ui.res.stringResource\r\nimport androidx.compose.ui.text.input.ImeAction\r\nimport androidx.compose.ui.text.input.KeyboardCapitalization\r\nimport androidx.compose.ui.text.input.KeyboardType\r\nimport androidx.compose.ui.text.input.VisualTransformation\r\nimport androidx.compose.ui.unit.IntSize\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.window.PopupProperties\r\nimport com.tutorly.R\r\nimport com.tutorly.models.SubjectPreset\r\nimport com.tutorly.ui.subject.SubjectSuggestionDefaults\r\nimport com.tutorly.ui.theme.extendedColors\r\nimport java.util.LinkedHashSet\r\nimport java.util.Locale\r\n\r\n@Composable\r\nprivate fun editorFieldColors(): TextFieldColors {\r\n    val colorScheme = MaterialTheme.colorScheme\r\n    val accent = MaterialTheme.extendedColors.accent\r\n    return OutlinedTextFieldDefaults.colors(\r\n        focusedContainerColor = colorScheme.surface,\r\n        unfocusedContainerColor = colorScheme.surface,\r\n        disabledContainerColor = colorScheme.surface,\r\n        errorContainerColor = colorScheme.surface,\r\n        focusedBorderColor = accent,\r\n        unfocusedBorderColor = accent.copy(alpha = 0.4f),\r\n        disabledBorderColor = accent.copy(alpha = 0.24f),\r\n        errorBorderColor = colorScheme.error\r\n    )\r\n}\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun StudentEditorForm(\r\n    state: StudentEditorFormState,\r\n    onNameChange: (String) -> Unit,\r\n    onPhoneChange: (String) -> Unit,\r\n    onMessengerChange: (String) -> Unit,\r\n    onRateChange: (String) -> Unit,\r\n    subjectPresets: List<SubjectPreset> = emptyList(),\r\n    onSubjectChange: (String) -> Unit,\r\n    onGradeChange: (String) -> Unit,\r\n    onNoteChange: (String) -> Unit,\r\n    modifier: Modifier = Modifier,\r\n    editTarget: StudentEditTarget? = null,\r\n    initialFocus: StudentEditTarget? = null,\r\n    enableScrolling: Boolean = true,\r\n    enabled: Boolean = true,\r\n    onSubmit: (() -> Unit)? = null,\r\n) {\r\n    val nameFocusRequester = remember { FocusRequester() }\r\n    val gradeFocusRequester = remember { FocusRequester() }\r\n    val rateFocusRequester = remember { FocusRequester() }\r\n    val phoneFocusRequester = remember { FocusRequester() }\r\n    val messengerFocusRequester = remember { FocusRequester() }\r\n    val noteFocusRequester = remember { FocusRequester() }\r\n    val scrollState = rememberScrollState()\r\n    LaunchedEffect(initialFocus, enabled) {\r\n        if (enabled) {\r\n            when (initialFocus) {\r\n                StudentEditTarget.PROFILE -> nameFocusRequester.safeRequestFocus()\r\n                StudentEditTarget.RATE -> rateFocusRequester.safeRequestFocus()\r\n                StudentEditTarget.PHONE -> phoneFocusRequester.safeRequestFocus()\r\n                StudentEditTarget.MESSENGER -> messengerFocusRequester.safeRequestFocus()\r\n                StudentEditTarget.NOTES -> noteFocusRequester.safeRequestFocus()\r\n                null -> Unit\r\n            }\r\n        }\r\n    }\r\n\r\n    val showFullForm = editTarget == null\r\n    val isNewStudent = state.studentId == null\r\n    var showAdditionalData by rememberSaveable(state.studentId) {\r\n        mutableStateOf(\r\n            !isNewStudent ||\r\n                state.phone.isNotBlank() ||\r\n                state.messenger.isNotBlank() ||\r\n                state.note.isNotBlank()\r\n        )\r\n    }\r\n\r\n    LaunchedEffect(editTarget) {\r\n        if (editTarget == StudentEditTarget.PHONE ||\r\n            editTarget == StudentEditTarget.MESSENGER ||\r\n            editTarget == StudentEditTarget.NOTES\r\n        ) {\r\n            showAdditionalData = true\r\n        }\r\n    }\r\n\r\n    val columnModifier = if (enableScrolling) {\r\n        modifier.verticalScroll(scrollState)\r\n    } else {\r\n        modifier\r\n    }\r\n\r\n    val textFieldColors = editorFieldColors()\r\n\r\n    Column(\r\n        modifier = columnModifier,\r\n        verticalArrangement = Arrangement.spacedBy(16.dp)\r\n    ) {\r\n        if (showFullForm || editTarget == StudentEditTarget.PROFILE) {\r\n            ProfileSection(\r\n                state = state,\r\n                subjectPresets = subjectPresets,\r\n                onNameChange = onNameChange,\r\n                onSubjectChange = onSubjectChange,\r\n                onGradeChange = onGradeChange,\r\n                enabled = enabled,\r\n                nameFocusRequester = nameFocusRequester,\r\n                gradeFocusRequester = gradeFocusRequester,\r\n                isStandalone = !showFullForm && editTarget == StudentEditTarget.PROFILE,\r\n                onSubmit = onSubmit\r\n            )\r\n        }\r\n\r\n        if (showFullForm || editTarget == StudentEditTarget.RATE) {\r\n            RateSection(\r\n                rate = state.rate,\r\n                onRateChange = onRateChange,\r\n                enabled = enabled,\r\n                focusRequester = rateFocusRequester,\r\n                isStandalone = !showFullForm && editTarget == StudentEditTarget.RATE,\r\n                onSubmit = onSubmit\r\n            )\r\n        }\r\n\r\n        val shouldShowAdditionalSections = !isNewStudent || showAdditionalData\r\n\r\n        if (showFullForm && isNewStudent) {\r\n            AdditionalDataToggle(\r\n                expanded = showAdditionalData,\r\n                onToggle = { showAdditionalData = !showAdditionalData },\r\n                enabled = enabled,\r\n                modifier = Modifier.align(Alignment.Start)\r\n            )\r\n        }\r\n\r\n        if ((showFullForm && shouldShowAdditionalSections) || editTarget == StudentEditTarget.PHONE) {\r\n            PhoneSection(\r\n                phone = state.phone,\r\n                onPhoneChange = onPhoneChange,\r\n                enabled = enabled,\r\n                focusRequester = phoneFocusRequester,\r\n                isStandalone = !showFullForm && editTarget == StudentEditTarget.PHONE,\r\n                onSubmit = onSubmit\r\n            )\r\n        }\r\n\r\n        if ((showFullForm && shouldShowAdditionalSections) || editTarget == StudentEditTarget.MESSENGER) {\r\n            MessengerSection(\r\n                messenger = state.messenger,\r\n                onMessengerChange = onMessengerChange,\r\n                enabled = enabled,\r\n                focusRequester = messengerFocusRequester,\r\n                isStandalone = !showFullForm && editTarget == StudentEditTarget.MESSENGER,\r\n                onSubmit = onSubmit\r\n            )\r\n        }\r\n\r\n        if ((showFullForm && shouldShowAdditionalSections) || editTarget == StudentEditTarget.NOTES) {\r\n            NotesSection(\r\n                note = state.note,\r\n                onNoteChange = onNoteChange,\r\n                enabled = enabled,\r\n                focusRequester = noteFocusRequester,\r\n                onSubmit = onSubmit\r\n            )\r\n        }\r\n\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun ProfileSection(\r\n    state: StudentEditorFormState,\r\n    subjectPresets: List<SubjectPreset>,\r\n    onNameChange: (String) -> Unit,\r\n    onSubjectChange: (String) -> Unit,\r\n    onGradeChange: (String) -> Unit,\r\n    enabled: Boolean,\r\n    nameFocusRequester: FocusRequester,\r\n    gradeFocusRequester: FocusRequester,\r\n    isStandalone: Boolean,\r\n    onSubmit: (() -> Unit)?,\r\n) {\r\n    val iconTint = MaterialTheme.colorScheme.onSurfaceVariant\r\n    val textFieldColors = editorFieldColors()\r\n    Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {\r\n        OutlinedTextField(\r\n            value = state.name,\r\n            onValueChange = onNameChange,\r\n            label = { Text(text = stringResource(id = R.string.student_editor_name)) },\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .focusRequester(nameFocusRequester),\r\n            singleLine = true,\r\n            enabled = enabled,\r\n            isError = state.nameError,\r\n            leadingIcon = {\r\n                Icon(\r\n                    imageVector = Icons.Filled.Person,\r\n                    contentDescription = null,\r\n                    tint = iconTint\r\n                )\r\n            },\r\n            keyboardOptions = KeyboardOptions.Default.copy(\r\n                capitalization = KeyboardCapitalization.Words,\r\n                imeAction = ImeAction.Next\r\n            ),\r\n            colors = textFieldColors\r\n        )\r\n        if (state.nameError) {\r\n            Text(\r\n                text = stringResource(id = R.string.student_editor_name_required),\r\n                style = MaterialTheme.typography.bodySmall,\r\n                color = MaterialTheme.colorScheme.error\r\n            )\r\n        }\r\n\r\n        SubjectSelector(\r\n            studentId = state.studentId,\r\n            subjectValue = state.subject,\r\n            subjectPresets = subjectPresets,\r\n            onSubjectChange = onSubjectChange,\r\n            enabled = enabled,\r\n            isStandalone = isStandalone,\r\n            onSubmit = onSubmit\r\n        )\r\n\r\n        OutlinedTextField(\r\n            value = state.grade,\r\n            onValueChange = onGradeChange,\r\n            label = { Text(text = stringResource(id = R.string.student_editor_grade)) },\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .focusRequester(gradeFocusRequester),\r\n            singleLine = true,\r\n            enabled = enabled,\r\n            leadingIcon = {\r\n                Icon(\r\n                    imageVector = Icons.Filled.School,\r\n                    contentDescription = null,\r\n                    tint = iconTint\r\n                )\r\n            },\r\n            keyboardOptions = KeyboardOptions.Default.copy(\r\n                capitalization = KeyboardCapitalization.Words,\r\n                imeAction = if (isStandalone) ImeAction.Done else ImeAction.Next\r\n            ),\r\n            keyboardActions = if (isStandalone) {\r\n                KeyboardActions(onDone = { onSubmit?.invoke() })\r\n            } else {\r\n                KeyboardActions.Default\r\n            },\r\n            colors = textFieldColors\r\n        )\r\n    }\r\n}\r\n@OptIn(ExperimentalLayoutApi::class)\r\n@Composable\r\nprivate fun SubjectSelector(\r\n    studentId: Long?,\r\n    subjectValue: String,\r\n    subjectPresets: List<SubjectPreset>,\r\n    onSubjectChange: (String) -> Unit,\r\n    enabled: Boolean,\r\n    isStandalone: Boolean,\r\n    onSubmit: (() -> Unit)?,\r\n) {\r\n    val locale = remember { Locale.getDefault() }\r\n    var subjectInput by remember { mutableStateOf(\"\") }\r\n    var selectedChips by remember { mutableStateOf<List<StudentSubjectChip>>(emptyList()) }\r\n    var expanded by remember { mutableStateOf(false) }\r\n    var textFieldSize by remember { mutableStateOf(IntSize.Zero) }\r\n    val dropdownWidth = with(LocalDensity.current) { textFieldSize.width.toDp() }\r\n    val dropdownModifier = if (dropdownWidth > 0.dp) Modifier.width(dropdownWidth) else Modifier\r\n    val interactionSource = remember { MutableInteractionSource() }\r\n    val textFieldColors = OutlinedTextFieldDefaults.colors(\r\n        focusedContainerColor = MaterialTheme.colorScheme.surface,\r\n        unfocusedContainerColor = MaterialTheme.colorScheme.surface,\r\n        disabledContainerColor = MaterialTheme.colorScheme.surface,\r\n        errorContainerColor = MaterialTheme.colorScheme.surface,\r\n        focusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.24f),\r\n        unfocusedBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.16f),\r\n        disabledBorderColor = MaterialTheme.colorScheme.outline.copy(alpha = 0.12f),\r\n        errorBorderColor = MaterialTheme.colorScheme.error\r\n    )\r\n    val presetLookup = remember(subjectPresets, locale) {\r\n        subjectPresets.associateBy { it.name.lowercase(locale) }\r\n    }\r\n\r\n    LaunchedEffect(studentId) { subjectInput = \"\" }\r\n\r\n    LaunchedEffect(subjectValue, subjectPresets) {\r\n        val tokens = subjectValue.split(',')\r\n            .map { it.trim() }\r\n            .filter { it.isNotEmpty() }\r\n        val chips = tokens.map { token ->\r\n            val preset = presetLookup[token.lowercase(locale)]\r\n            if (preset != null) {\r\n                preset.toChip()\r\n            } else {\r\n                StudentSubjectChip(id = null, name = normalizeSubjectLabel(token), colorArgb = null)\r\n            }\r\n        }\r\n        selectedChips = chips\r\n        subjectInput = \"\"\r\n    }\r\n\r\n    val trimmedQuery = subjectInput.trim()\r\n    val normalizedQuery = trimmedQuery.lowercase(locale)\r\n    val hasQuery = normalizedQuery.isNotEmpty()\r\n    val matchingPresets = if (hasQuery) {\r\n        subjectPresets.filter { option ->\r\n            option.name.lowercase(locale).startsWith(normalizedQuery)\r\n        }\r\n    } else {\r\n        emptyList()\r\n    }\r\n    val matchingDefaults = if (hasQuery) {\r\n        SubjectSuggestionDefaults.filter { suggestion ->\r\n            val normalized = suggestion.lowercase(locale)\r\n            normalized.startsWith(normalizedQuery) &&\r\n                subjectPresets.none { it.name.equals(suggestion, ignoreCase = true) }\r\n        }\r\n    } else {\r\n        emptyList()\r\n    }\r\n    val hasSuggestions = matchingPresets.isNotEmpty() || matchingDefaults.isNotEmpty()\r\n\r\n    fun updateChips(updated: List<StudentSubjectChip>) {\r\n        selectedChips = updated\r\n        onSubjectChange(buildSubjectValue(updated))\r\n    }\r\n\r\n    fun addPreset(option: SubjectPreset) {\r\n        if (selectedChips.any { it.id == option.id }) {\r\n            subjectInput = \"\"\r\n            expanded = false\r\n            return\r\n        }\r\n        updateChips(selectedChips + option.toChip())\r\n        subjectInput = \"\"\r\n        expanded = false\r\n    }\r\n\r\n    fun toggleSuggestion(name: String) {\r\n        val normalized = name.trim()\r\n        if (normalized.isEmpty()) {\r\n            subjectInput = \"\"\r\n            expanded = false\r\n            return\r\n        }\r\n        val existingIndex = selectedChips.indexOfFirst { chip ->\r\n            chip.id == null && chip.name.equals(normalized, ignoreCase = true)\r\n        }\r\n        val updated = if (existingIndex >= 0) {\r\n            selectedChips.toMutableList().also { it.removeAt(existingIndex) }\r\n        } else {\r\n            val displayName = normalizeSubjectLabel(normalized)\r\n            selectedChips + StudentSubjectChip(id = null, name = displayName, colorArgb = null)\r\n        }\r\n        updateChips(updated)\r\n        subjectInput = \"\"\r\n        expanded = false\r\n    }\r\n\r\n    fun removeChip(chip: StudentSubjectChip) {\r\n        val updated = if (chip.id != null) {\r\n            selectedChips.filterNot { it.id == chip.id }\r\n        } else {\r\n            selectedChips.filterNot {\r\n                it.id == null && it.name.equals(chip.name, ignoreCase = true)\r\n            }\r\n        }\r\n        updateChips(updated)\r\n    }\r\n\r\n    fun commitInput(): Boolean {\r\n        if (trimmedQuery.isEmpty()) {\r\n            return false\r\n        }\r\n        if (selectedChips.any { it.name.equals(trimmedQuery, ignoreCase = true) }) {\r\n            subjectInput = \"\"\r\n            expanded = false\r\n            return true\r\n        }\r\n        val displayName = normalizeSubjectLabel(trimmedQuery)\r\n        updateChips(\r\n            selectedChips + StudentSubjectChip(id = null, name = displayName, colorArgb = null)\r\n        )\r\n        subjectInput = \"\"\r\n        expanded = false\r\n        return true\r\n    }\r\n\r\n    LaunchedEffect(hasSuggestions) {\r\n        if (!hasSuggestions) {\r\n            expanded = false\r\n        }\r\n    }\r\n\r\n    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {\r\n        Box {\r\n            BasicTextField(\r\n                value = subjectInput,\r\n                onValueChange = { raw ->\r\n                    subjectInput = raw\r\n                    expanded = enabled && raw.trim().isNotEmpty()\r\n                },\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .onGloballyPositioned { textFieldSize = it.size }\r\n                    .onFocusChanged { focusState ->\r\n                        expanded = enabled && focusState.isFocused && hasSuggestions\r\n                    },\r\n                singleLine = true,\r\n                enabled = enabled,\r\n                textStyle = LocalTextStyle.current.copy(color = MaterialTheme.colorScheme.onSurface),\r\n                cursorBrush = SolidColor(MaterialTheme.colorScheme.primary),\r\n                interactionSource = interactionSource,\r\n                keyboardOptions = KeyboardOptions.Default.copy(\r\n                    capitalization = KeyboardCapitalization.Words,\r\n                    imeAction = if (isStandalone) ImeAction.Done else ImeAction.Next\r\n                ),\r\n                keyboardActions = if (isStandalone) {\r\n                    KeyboardActions(onDone = {\r\n                        val consumed = commitInput()\r\n                        if (!consumed) {\r\n                            defaultKeyboardAction(ImeAction.Done)\r\n                        }\r\n                        onSubmit?.invoke()\r\n                    })\r\n                } else {\r\n                    KeyboardActions(onNext = {\r\n                        val consumed = commitInput()\r\n                        if (!consumed) {\r\n                            defaultKeyboardAction(ImeAction.Next)\r\n                        }\r\n                    })\r\n                },\r\n                decorationBox = { innerTextField ->\r\n                    val labelValue = remember(subjectInput, selectedChips) {\r\n                        when {\r\n                            subjectInput.isNotEmpty() -> subjectInput\r\n                            selectedChips.isNotEmpty() -> \" \"\r\n                            else -> \"\"\r\n                        }\r\n                    }\r\n                    OutlinedTextFieldDefaults.DecorationBox(\r\n                        value = labelValue,\r\n                        visualTransformation = VisualTransformation.None,\r\n                        innerTextField = {\r\n                            Row(\r\n                                modifier = Modifier.fillMaxWidth(),\r\n                                horizontalArrangement = Arrangement.spacedBy(8.dp),\r\n                                verticalAlignment = Alignment.CenterVertically\r\n                            ) {\r\n                                if (selectedChips.isNotEmpty()) {\r\n                                    FlowRow(\r\n                                        horizontalArrangement = Arrangement.spacedBy(8.dp),\r\n                                        verticalArrangement = Arrangement.Center\r\n                                    ) {\r\n                                        selectedChips.forEach { chip ->\r\n                                            FilterChip(\r\n                                                selected = true,\r\n                                                onClick = {\r\n                                                    if (enabled) {\r\n                                                        removeChip(chip)\r\n                                                    }\r\n                                                },\r\n                                                label = { Text(text = chip.name) },\r\n                                                leadingIcon = {\r\n                                                    chip.colorArgb?.let { color ->\r\n                                                        Box(\r\n                                                            modifier = Modifier\r\n                                                                .size(12.dp)\r\n                                                                .background(Color(color), CircleShape)\r\n                                                        )\r\n                                                    }\r\n                                                },\r\n                                                trailingIcon = {\r\n                                                    Icon(\r\n                                                        imageVector = Icons.Filled.Close,\r\n                                                        contentDescription = null,\r\n                                                        modifier = Modifier.size(16.dp)\r\n                                                    )\r\n                                                },\r\n                                                colors = FilterChipDefaults.filterChipColors(\r\n                                                    selectedContainerColor = MaterialTheme.extendedColors.chipSelected,\r\n                                                    selectedLabelColor = MaterialTheme.colorScheme.onSurface\r\n                                                ),\r\n                                                enabled = enabled\r\n                                            )\r\n                                        }\r\n                                    }\r\n                                }\r\n                                Box(modifier = Modifier.weight(1f, fill = true)) {\r\n                                    innerTextField()\r\n                                }\r\n                            }\r\n                        },\r\n                        label = { Text(text = stringResource(id = R.string.student_editor_subject)) },\r\n                        placeholder = null,\r\n                        leadingIcon = { Icon(imageVector = Icons.Filled.Book, contentDescription = null) },\r\n                        trailingIcon = null,\r\n                        supportingText = null,\r\n                        singleLine = true,\r\n                        enabled = enabled,\r\n                        isError = false,\r\n                        interactionSource = interactionSource,\r\n                        colors = textFieldColors,\r\n                        contentPadding = OutlinedTextFieldDefaults.contentPadding()\r\n                    )\r\n                }\r\n            )\r\n\r\n            DropdownMenu(\r\n                expanded = expanded && hasSuggestions,\r\n                onDismissRequest = { expanded = false },\r\n                modifier = dropdownModifier,\r\n                containerColor = MaterialTheme.colorScheme.surface,\r\n                properties = PopupProperties(focusable = false)\r\n            ) {\r\n                matchingPresets.forEach { option ->\r\n                    val isSelected = selectedChips.any { it.id == option.id }\r\n                    DropdownMenuItem(\r\n                        text = {\r\n                            Row(\r\n                                verticalAlignment = Alignment.CenterVertically,\r\n                                horizontalArrangement = Arrangement.spacedBy(12.dp)\r\n                            ) {\r\n                                Box(\r\n                                    modifier = Modifier\r\n                                        .size(12.dp)\r\n                                        .background(Color(option.colorArgb), CircleShape)\r\n                                )\r\n                                Text(text = option.name)\r\n                            }\r\n                        },\r\n                        trailingIcon = {\r\n                            if (isSelected) {\r\n                                Icon(imageVector = Icons.Filled.Check, contentDescription = null)\r\n                            }\r\n                        },\r\n                        onClick = { addPreset(option) }\r\n                    )\r\n                }\r\n                matchingDefaults.forEach { suggestion ->\r\n                    val isSelected = selectedChips.any {\r\n                        it.id == null && it.name.equals(suggestion, ignoreCase = true)\r\n                    }\r\n                    DropdownMenuItem(\r\n                        text = { Text(text = suggestion) },\r\n                        trailingIcon = {\r\n                            if (isSelected) {\r\n                                Icon(imageVector = Icons.Filled.Check, contentDescription = null)\r\n                            }\r\n                        },\r\n                        onClick = { toggleSuggestion(suggestion) }\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate data class StudentSubjectChip(\r\n    val id: Long?,\r\n    val name: String,\r\n    val colorArgb: Int?\r\n)\r\n\r\nprivate fun SubjectPreset.toChip(): StudentSubjectChip =\r\n    StudentSubjectChip(id = id, name = name, colorArgb = colorArgb)\r\n\r\nprivate fun buildSubjectValue(chips: List<StudentSubjectChip>): String {\r\n    val seen = LinkedHashSet<String>()\r\n    val ordered = mutableListOf<String>()\r\n    chips.forEach { chip ->\r\n        val trimmed = chip.name.trim()\r\n        if (trimmed.isNotEmpty()) {\r\n            val normalized = trimmed.lowercase(Locale.getDefault())\r\n            if (seen.add(normalized)) {\r\n                ordered.add(normalizeSubjectLabel(trimmed))\r\n            }\r\n        }\r\n    }\r\n    return ordered.joinToString(separator = \", \")\r\n}\r\n\r\n@Composable\r\nprivate fun RateSection(\r\n    rate: String,\r\n    onRateChange: (String) -> Unit,\r\n    enabled: Boolean,\r\n    focusRequester: FocusRequester,\r\n    isStandalone: Boolean,\r\n    onSubmit: (() -> Unit)?,\r\n) {\r\n    val iconTint = MaterialTheme.colorScheme.onSurfaceVariant\r\n    val textFieldColors = editorFieldColors()\r\n\r\n    OutlinedTextField(\r\n        value = rate,\r\n        onValueChange = onRateChange,\r\n        label = { Text(text = stringResource(id = R.string.student_editor_rate)) },\r\n        modifier = Modifier\r\n            .fillMaxWidth()\r\n            .focusRequester(focusRequester),\r\n        singleLine = true,\r\n        enabled = enabled,\r\n        leadingIcon = {\r\n            Icon(\r\n                imageVector = Icons.Outlined.CurrencyRuble,\r\n                contentDescription = null,\r\n                tint = iconTint\r\n            )\r\n        },\r\n        supportingText = {\r\n            Text(text = stringResource(id = R.string.student_editor_rate_support))\r\n        },\r\n        keyboardOptions = KeyboardOptions.Default.copy(\r\n            keyboardType = KeyboardType.Decimal,\r\n            imeAction = if (isStandalone) ImeAction.Done else ImeAction.Next\r\n        ),\r\n        keyboardActions = if (isStandalone) {\r\n            KeyboardActions(onDone = { onSubmit?.invoke() })\r\n        } else {\r\n            KeyboardActions.Default\r\n        },\r\n        colors = textFieldColors\r\n    )\r\n}\r\n\r\n@Composable\r\nprivate fun AdditionalDataToggle(\r\n    expanded: Boolean,\r\n    onToggle: () -> Unit,\r\n    enabled: Boolean,\r\n    modifier: Modifier = Modifier,\r\n) {\r\n    val title = stringResource(id = R.string.student_editor_additional_data_title)\r\n    val description = stringResource(\r\n        id = if (expanded) {\r\n            R.string.student_editor_additional_data_hide\r\n        } else {\r\n            R.string.student_editor_additional_data_show\r\n        }\r\n    )\r\n    TextButton(\r\n        onClick = onToggle,\r\n        modifier = modifier,\r\n        enabled = enabled\r\n    ) {\r\n        Text(text = title)\r\n        Spacer(modifier = Modifier.width(8.dp))\r\n        Icon(\r\n            imageVector = if (expanded) Icons.Filled.ArrowDropUp else Icons.Filled.ArrowDropDown,\r\n            contentDescription = description\r\n        )\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun PhoneSection(\r\n    phone: String,\r\n    onPhoneChange: (String) -> Unit,\r\n    enabled: Boolean,\r\n    focusRequester: FocusRequester,\r\n    isStandalone: Boolean,\r\n    onSubmit: (() -> Unit)?,\r\n) {\r\n    val iconTint = MaterialTheme.colorScheme.onSurfaceVariant\r\n    val textFieldColors = editorFieldColors()\r\n    OutlinedTextField(\r\n        value = phone,\r\n        onValueChange = onPhoneChange,\r\n        label = { Text(text = stringResource(id = R.string.student_editor_phone)) },\r\n        modifier = Modifier\r\n            .fillMaxWidth()\r\n            .focusRequester(focusRequester),\r\n        singleLine = true,\r\n        enabled = enabled,\r\n        leadingIcon = {\r\n            Icon(\r\n                imageVector = Icons.Filled.Phone,\r\n                contentDescription = null,\r\n                tint = iconTint\r\n            )\r\n        },\r\n        keyboardOptions = KeyboardOptions.Default.copy(\r\n            imeAction = if (isStandalone) ImeAction.Done else ImeAction.Next\r\n        ),\r\n        keyboardActions = if (isStandalone) {\r\n            KeyboardActions(onDone = { onSubmit?.invoke() })\r\n        } else {\r\n            KeyboardActions.Default\r\n        },\r\n        colors = textFieldColors\r\n    )\r\n}\r\n\r\n@Composable\r\nprivate fun MessengerSection(\r\n    messenger: String,\r\n    onMessengerChange: (String) -> Unit,\r\n    enabled: Boolean,\r\n    focusRequester: FocusRequester,\r\n    isStandalone: Boolean,\r\n    onSubmit: (() -> Unit)?,\r\n) {\r\n    val messengerOptions = remember { StudentMessengerType.values().toList() }\r\n    var selectedType by remember { mutableStateOf(StudentMessengerType.TELEGRAM) }\r\n    var customLabel by remember { mutableStateOf(\"\") }\r\n    var identifier by remember { mutableStateOf(\"\") }\r\n    val iconTint = MaterialTheme.colorScheme.onSurfaceVariant\r\n    val textFieldColors = editorFieldColors()\r\n\r\n    LaunchedEffect(messenger) {\r\n        val parsed = messenger.parseMessengerValue()\r\n        selectedType = parsed.type\r\n        customLabel = parsed.customLabel\r\n        identifier = parsed.identifier\r\n    }\r\n\r\n    Column(verticalArrangement = Arrangement.spacedBy(12.dp)) {\r\n        var isDropdownExpanded by remember { mutableStateOf(false) }\r\n        Box {\r\n            OutlinedTextField(\r\n                value = if (selectedType == StudentMessengerType.OTHER) customLabel else stringResource(id = selectedType.labelRes),\r\n                onValueChange = {\r\n                    if (selectedType == StudentMessengerType.OTHER) {\r\n                        customLabel = it\r\n                        onMessengerChange(buildMessengerValue(selectedType, customLabel, identifier))\r\n                    }\r\n                },\r\n                label = { Text(text = stringResource(id = R.string.student_editor_messenger_type)) },\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .onFocusChanged { focusState ->\r\n                        if (enabled && focusState.isFocused) {\r\n                            isDropdownExpanded = true\r\n                        }\r\n                    },\r\n                enabled = enabled,\r\n                readOnly = selectedType != StudentMessengerType.OTHER,\r\n                leadingIcon = {\r\n                    Icon(\r\n                        imageVector = Icons.Filled.Message,\r\n                        contentDescription = null,\r\n                        tint = iconTint\r\n                    )\r\n                },\r\n                trailingIcon = {\r\n                    IconButton(onClick = { isDropdownExpanded = !isDropdownExpanded }, enabled = enabled) {\r\n                        Icon(\r\n                            imageVector = if (isDropdownExpanded) Icons.Filled.ArrowDropUp else Icons.Filled.ArrowDropDown,\r\n                            contentDescription = null,\r\n                            tint = iconTint\r\n                        )\r\n                    }\r\n                },\r\n                keyboardOptions = KeyboardOptions.Default.copy(\r\n                    capitalization = KeyboardCapitalization.Words,\r\n                    imeAction = ImeAction.Next\r\n                ),\r\n                colors = textFieldColors\r\n            )\r\n\r\n            DropdownMenu(\r\n                expanded = isDropdownExpanded,\r\n                onDismissRequest = { isDropdownExpanded = false },\r\n                containerColor = MaterialTheme.colorScheme.surface\r\n            ) {\r\n                messengerOptions.forEach { option ->\r\n                    DropdownMenuItem(\r\n                        text = { Text(text = stringResource(id = option.labelRes)) },\r\n                        onClick = {\r\n                            isDropdownExpanded = false\r\n                            selectedType = option\r\n                            if (option != StudentMessengerType.OTHER) {\r\n                                customLabel = \"\"\r\n                            }\r\n                            onMessengerChange(buildMessengerValue(selectedType, customLabel, identifier))\r\n                        },\r\n                        enabled = enabled\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        OutlinedTextField(\r\n            value = identifier,\r\n            onValueChange = {\r\n                identifier = it\r\n                onMessengerChange(buildMessengerValue(selectedType, customLabel, identifier))\r\n            },\r\n            label = { Text(text = stringResource(id = R.string.student_editor_messenger_id)) },\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .focusRequester(focusRequester),\r\n            singleLine = true,\r\n            enabled = enabled,\r\n            leadingIcon = {\r\n                Icon(\r\n                    imageVector = Icons.Filled.AlternateEmail,\r\n                    contentDescription = null,\r\n                    tint = iconTint\r\n                )\r\n            },\r\n            keyboardOptions = KeyboardOptions.Default.copy(\r\n                imeAction = if (isStandalone) ImeAction.Done else ImeAction.Next\r\n            ),\r\n            keyboardActions = if (isStandalone) {\r\n                KeyboardActions(onDone = { onSubmit?.invoke() })\r\n            } else {\r\n                KeyboardActions.Default\r\n            },\r\n            colors = textFieldColors\r\n        )\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun NotesSection(\r\n    note: String,\r\n    onNoteChange: (String) -> Unit,\r\n    enabled: Boolean,\r\n    focusRequester: FocusRequester,\r\n    onSubmit: (() -> Unit)?\r\n) {\r\n    val iconTint = MaterialTheme.colorScheme.onSurfaceVariant\r\n    val textFieldColors = editorFieldColors()\r\n    OutlinedTextField(\r\n        value = note,\r\n        onValueChange = onNoteChange,\r\n        label = { Text(text = stringResource(id = R.string.student_editor_notes)) },\r\n        modifier = Modifier\r\n            .fillMaxWidth()\r\n            .focusRequester(focusRequester),\r\n        minLines = 3,\r\n        enabled = enabled,\r\n        leadingIcon = {\r\n            Icon(\r\n                imageVector = Icons.Filled.Description,\r\n                contentDescription = null,\r\n                tint = iconTint\r\n            )\r\n        },\r\n        keyboardOptions = KeyboardOptions.Default.copy(\r\n            capitalization = KeyboardCapitalization.Words,\r\n            imeAction = ImeAction.Done\r\n        ),\r\n        keyboardActions = KeyboardActions(onDone = {\r\n            onSubmit?.invoke()\r\n        }),\r\n        colors = textFieldColors\r\n    )\r\n}\r\n\r\nprivate suspend fun FocusRequester.safeRequestFocus() {\r\n    repeat(5) {\r\n        if (tryRequestFocus()) {\r\n            return\r\n        }\r\n        // When the dialog is first shown the focus target might not yet be attached.\r\n        // Wait for the next frame so Compose has a chance to attach the node before retrying.\r\n        withFrameNanos { }\r\n    }\r\n    tryRequestFocus()\r\n}\r\n\r\nprivate fun FocusRequester.tryRequestFocus(): Boolean =\r\n    runCatching { requestFocus() }.isSuccess\r\n\r\nprivate data class MessengerValue(\r\n    val type: StudentMessengerType,\r\n    val customLabel: String,\r\n    val identifier: String\r\n)\r\n\r\nprivate fun String.parseMessengerValue(): MessengerValue {\r\n    val raw = trim()\r\n    if (raw.isEmpty()) {\r\n        return MessengerValue(StudentMessengerType.TELEGRAM, \"\", \"\")\r\n    }\r\n\r\n    val delimiterIndex = raw.indexOf(':')\r\n    if (delimiterIndex == -1) {\r\n        return MessengerValue(StudentMessengerType.OTHER, \"\", raw)\r\n    }\r\n\r\n    val label = raw.substring(0, delimiterIndex).trim()\r\n    val value = raw.substring(delimiterIndex + 1).trim()\r\n    val type = StudentMessengerType.fromLabel(label)\r\n    return if (type == StudentMessengerType.OTHER) {\r\n        MessengerValue(type, label, value)\r\n    } else {\r\n        MessengerValue(type, \"\", value)\r\n    }\r\n}\r\n\r\nprivate fun buildMessengerValue(\r\n    type: StudentMessengerType,\r\n    customLabel: String,\r\n    identifier: String\r\n): String {\r\n    val trimmedIdentifier = identifier.trim()\r\n    if (trimmedIdentifier.isEmpty()) {\r\n        return \"\"\r\n    }\r\n\r\n    val label = when (type) {\r\n        StudentMessengerType.OTHER -> customLabel.trim()\r\n        else -> type.label\r\n    }\r\n\r\n    return if (label.isNotEmpty()) {\r\n        \"$label: $trimmedIdentifier\"\r\n    } else {\r\n        trimmedIdentifier\r\n    }\r\n}\r\n\r\n\r\n\r\nprivate enum class StudentMessengerType(\r\n    val label: String,\r\n    val labelRes: Int,\r\n) {\r\n    TELEGRAM(label = \"Telegram\", labelRes = R.string.student_editor_messenger_type_telegram),\r\n    WHATSAPP(label = \"WhatsApp\", labelRes = R.string.student_editor_messenger_type_whatsapp),\r\n    VIBER(label = \"Viber\", labelRes = R.string.student_editor_messenger_type_viber),\r\n    VK(label = \"VK\", labelRes = R.string.student_editor_messenger_type_vk),\r\n    OTHER(label = \"\", labelRes = R.string.student_editor_messenger_type_other);\r\n\r\n    companion object {\r\n        fun fromLabel(label: String): StudentMessengerType {\r\n            val normalized = label.lowercase(Locale.getDefault())\r\n            return values().firstOrNull { option ->\r\n                option.label.lowercase(Locale.getDefault()) == normalized && option != OTHER\r\n            } ?: OTHER\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/ui/screens/StudentEditorForm.kt b/app/src/main/java/com/tutorly/ui/screens/StudentEditorForm.kt
--- a/app/src/main/java/com/tutorly/ui/screens/StudentEditorForm.kt	(revision 415fe506c4006cec2c40a1b41c1d439650486410)
+++ b/app/src/main/java/com/tutorly/ui/screens/StudentEditorForm.kt	(date 1761075720214)
@@ -1,6 +1,5 @@
 package com.tutorly.ui.screens
 
-import androidx.compose.foundation.ExperimentalLayoutApi
 import androidx.compose.foundation.background
 import androidx.compose.foundation.interaction.MutableInteractionSource
 import androidx.compose.foundation.layout.*
@@ -30,6 +29,7 @@
 import androidx.compose.material3.FilterChipDefaults
 import androidx.compose.material3.Icon
 import androidx.compose.material3.IconButton
+import androidx.compose.material3.LocalTextStyle
 import androidx.compose.material3.MaterialTheme
 import androidx.compose.material3.OutlinedTextField
 import androidx.compose.material3.OutlinedTextFieldDefaults
@@ -47,7 +47,6 @@
 import androidx.compose.ui.graphics.SolidColor
 import androidx.compose.ui.layout.onGloballyPositioned
 import androidx.compose.ui.platform.LocalDensity
-import androidx.compose.ui.platform.LocalTextStyle
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.text.input.ImeAction
 import androidx.compose.ui.text.input.KeyboardCapitalization
