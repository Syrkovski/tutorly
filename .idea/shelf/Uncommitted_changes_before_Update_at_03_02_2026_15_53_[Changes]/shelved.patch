Index: app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.data.repo.memory\r\n\r\nimport com.tutorly.domain.model.LessonCreateRequest\r\nimport com.tutorly.domain.model.LessonDetails\r\nimport com.tutorly.domain.model.LessonForToday\nimport com.tutorly.domain.model.LessonsRangeStats\nimport com.tutorly.domain.model.asIcon\nimport com.tutorly.domain.model.resolveDuration\nimport com.tutorly.domain.repo.LessonsRepository\nimport com.tutorly.models.Lesson\nimport com.tutorly.domain.recurrence.RecurrenceLabelFormatter\nimport com.tutorly.models.Payment\nimport com.tutorly.models.PaymentStatus\nimport com.tutorly.models.LessonStatus\nimport com.tutorly.models.LessonRecurrence\nimport com.tutorly.models.RecurrenceFrequency\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.map\nimport java.time.Duration\nimport java.time.Instant\nimport java.time.temporal.TemporalAdjusters\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.concurrent.atomic.AtomicLong\n\nclass InMemoryLessonsRepository : LessonsRepository {\n    private val seq = AtomicLong(1)\n    private val recurrenceSeq = AtomicLong(1)\n    private val store = ConcurrentHashMap<Long, Lesson>()\r\n    private val lessonsFlow = MutableStateFlow<List<Lesson>>(emptyList())\r\n    private val payments = ConcurrentHashMap<Long, Payment>()\r\n\r\n    override fun observeLessons(from: Instant, to: Instant): Flow<List<LessonDetails>> =\n        lessonsFlow.map { lessons ->\n            val base = lessons.filter { it.startAt >= from && it.startAt < to }\n                .map { it.toDetailsStub() }\n            val generated = lessons.flatMap { lesson -> lesson.expandRecurrenceDetails(from, to) }\n            (base + generated).sortedBy { it.startAt }\n        }\n\n    override fun observeTodayLessons(dayStart: Instant, dayEnd: Instant): Flow<List<LessonForToday>> =\n        lessonsFlow.map { lessons ->\n            val base = lessons.filter { it.startAt >= dayStart && it.startAt < dayEnd }\n                .map { it.toTodayStub() }\n            val generated = lessons.flatMap { lesson -> lesson.expandRecurrenceToday(dayStart, dayEnd) }\n            (base + generated).sortedBy { it.startAt }\n        }\n\n    override fun observeOutstandingLessons(before: Instant): Flow<List<LessonForToday>> =\n        lessonsFlow.map { lessons ->\n            val base = lessons.filter { it.startAt < before && it.paymentStatus in PaymentStatus.outstandingStatuses }\n                .map { it.toTodayStub() }\n            val generated = lessons\n                .filter { it.paymentStatus in PaymentStatus.outstandingStatuses }\n                .flatMap { lesson -> lesson.expandRecurrenceToday(Instant.EPOCH, before) }\n            (base + generated).sortedBy { it.startAt }\n        }\n\n    override fun observeOutstandingLessonDetails(before: Instant): Flow<List<LessonDetails>> =\n        lessonsFlow.map { lessons ->\n            val base = lessons.filter { it.startAt < before && it.paymentStatus in PaymentStatus.outstandingStatuses }\n                .map { it.toDetailsStub() }\n            val generated = lessons\n                .filter { it.paymentStatus in PaymentStatus.outstandingStatuses }\n                .flatMap { lesson -> lesson.expandRecurrenceDetails(Instant.EPOCH, before) }\n            (base + generated).sortedBy { it.startAt }\n        }\n\n    override fun observeWeekStats(from: Instant, to: Instant): Flow<LessonsRangeStats> =\r\n        lessonsFlow.map { lessons ->\r\n            val relevant = lessons.filter { it.startAt >= from && it.startAt < to }\r\n            val paidStatus = PaymentStatus.PAID\r\n            val outstanding = PaymentStatus.outstandingStatuses.toSet()\r\n            LessonsRangeStats(\r\n                totalLessons = relevant.size,\r\n                paidLessons = relevant.count { it.paymentStatus == paidStatus },\r\n                debtLessons = relevant.count { it.paymentStatus in outstanding },\r\n                earnedCents = relevant\r\n                    .filter { it.paymentStatus == paidStatus }\r\n                    .sumOf { it.paidCents.toLong() }\r\n            )\r\n        }\r\n\r\n    override fun observeLessonDetails(id: Long): Flow<LessonDetails?> =\n        lessonsFlow.map { lessons -> lessons.firstOrNull { it.id == id }?.toDetailsStub() }\n\n    override fun observeByStudent(studentId: Long): Flow<List<Lesson>> =\n        lessonsFlow.map { lessons -> lessons.filter { it.studentId == studentId } }\n\n    override suspend fun getById(id: Long): Lesson? = store[id]\n\n    override suspend fun upsert(lesson: Lesson): Long {\n        val id = if (lesson.id == 0L) seq.getAndIncrement() else lesson.id\n        val existing = store[id]\n        val updated = when {\n            lesson.recurrence != null -> {\n                val seriesId = lesson.seriesId ?: existing?.seriesId ?: recurrenceSeq.getAndIncrement()\n                lesson.copy(id = id, seriesId = seriesId)\n            }\n\n            existing?.seriesId != null && lesson.seriesId == null -> {\n                lesson.copy(id = id, recurrence = null)\n            }\n\n            else -> {\n                val recurrence = existing?.recurrence\n                lesson.copy(id = id, recurrence = recurrence, seriesId = lesson.seriesId ?: existing?.seriesId)\n            }\n        }\n        store[id] = updated\n        emit()\n        return id\n    }\n\n    override suspend fun create(request: LessonCreateRequest): Long {\n        val id = seq.getAndIncrement()\n        val now = Instant.now()\n        val recurrence = request.recurrence?.let { rule ->\n            LessonRecurrence(\n                frequency = rule.frequency,\n                interval = rule.interval,\n                daysOfWeek = rule.daysOfWeek,\n                startDateTime = request.startAt,\n                untilDateTime = rule.until,\n                timezone = rule.timezone\n            )\n        }\n        val seriesId = recurrence?.let { recurrenceSeq.getAndIncrement() }\n        val newLesson = Lesson(\n            id = id,\n            studentId = request.studentId,\n            subjectId = request.subjectId,\n            title = request.title,\n            startAt = request.startAt,\n            endAt = request.endAt,\n            priceCents = request.priceCents,\n            paidCents = 0,\n            paymentStatus = PaymentStatus.UNPAID,\n            markedAt = null,\n            status = LessonStatus.PLANNED,\n            note = request.note,\n            createdAt = now,\n            updatedAt = now,\n            seriesId = seriesId,\n            isInstance = false,\n            recurrence = recurrence\n        )\n        store[id] = newLesson\n        emit()\n        return id\n    }\n\n    override suspend fun moveLesson(lessonId: Long, newStart: Instant, newEnd: Instant) {\n        store[lessonId]?.let { lesson ->\n            store[lessonId] = lesson.copy(\n                startAt = newStart,\n                endAt = newEnd,\n                updatedAt = Instant.now()\n            )\n            emit()\n        }\n    }\n\n    override suspend fun moveRecurringOccurrence(\n        seriesId: Long,\n        originalStart: Instant,\n        newStart: Instant,\n        duration: Duration\n    ) {\n        // Recurrence support is not implemented in the in-memory repository used for tests.\n    }\n\n    override suspend fun clearRecurringOverride(seriesId: Long, originalStart: Instant) {\n        // Recurrence support is not implemented in the in-memory repository used for tests.\n    }\n\r\n    override suspend fun findConflicts(start: Instant, end: Instant): List<LessonDetails> {\r\n        return store.values\r\n            .filter { lesson -> lesson.startAt < end && lesson.endAt > start }\r\n            .sortedBy { it.startAt }\r\n            .map { it.toDetailsStub() }\r\n    }\r\n\r\n    override suspend fun latestLessonForStudent(studentId: Long): Lesson? {\n        return store.values\n            .filter { it.studentId == studentId }\n            .maxByOrNull { it.startAt }\n    }\n\n    override suspend fun delete(id: Long) {\n        store.remove(id)\n        payments.remove(id)\n        emit()\n    }\n\n    override suspend fun markPaid(id: Long) {\n        store[id]?.let { lesson ->\n            val now = Instant.now()\n            val updatedLesson = lesson.copy(\n                paymentStatus = PaymentStatus.PAID,\n                paidCents = lesson.priceCents,\n                markedAt = now\n            )\n            store[id] = updatedLesson\n            val payment = payments[id]\n            payments[id] = (payment ?: Payment(\n                id = id,\n                lessonId = updatedLesson.id,\n                studentId = updatedLesson.studentId,\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.PAID,\r\n                at = now\r\n            )).copy(\r\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.PAID,\r\n                at = now\r\n            )\r\n            emit()\r\n        }\r\n    }\r\n\r\n    override suspend fun markDue(id: Long) {\r\n        store[id]?.let { lesson ->\r\n            val now = Instant.now()\n            val updatedLesson = lesson.copy(\n                paymentStatus = PaymentStatus.DUE,\n                paidCents = 0,\n                markedAt = now\n            )\n            store[id] = updatedLesson\n            val payment = payments[id]\n            payments[id] = (payment ?: Payment(\n                id = id,\n                lessonId = updatedLesson.id,\n                studentId = updatedLesson.studentId,\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.DUE,\r\n                at = now\r\n            )).copy(\r\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.DUE,\r\n                at = now\r\n            )\r\n            emit()\r\n        }\r\n    }\r\n\r\n    override suspend fun saveNote(id: Long, note: String?) {\n        store[id]?.let {\n            store[id] = it.copy(note = note)\n            emit()\n        }\n    }\n\n    override suspend fun resetPaymentStatus(id: Long) {\n        store[id]?.let { lesson ->\n            store[id] = lesson.copy(\n                paymentStatus = PaymentStatus.UNPAID,\n                paidCents = 0,\n                markedAt = null\n            )\n            payments.remove(id)\n            emit()\n        }\n    }\n\r\n    private fun emit() {\n        lessonsFlow.value = store.values.sortedByDescending { it.startAt }\n    }\n}\n\nprivate fun Lesson.expandRecurrenceDetails(rangeStart: Instant, rangeEnd: Instant): List<LessonDetails> {\n    val recurrence = recurrence ?: return emptyList()\n    if (rangeStart >= rangeEnd) return emptyList()\n    val occurrences = expandRecurrence(rangeStart, rangeEnd, recurrence)\n    if (occurrences.isEmpty()) return emptyList()\n    val base = toDetailsStub()\n    val duration = base.duration\n    val seriesId = seriesId ?: id\n    return occurrences.map { occurrence ->\n        base.copy(\n            id = syntheticId(seriesId, occurrence),\n            baseLessonId = id,\n            startAt = occurrence,\n            endAt = occurrence.plus(duration),\n            duration = duration,\n            paidCents = 0,\n            isRecurring = true,\n            seriesId = seriesId,\n            originalStartAt = occurrence,\n            recurrenceLabel = base.recurrenceLabel\n        )\n    }\n}\n\nprivate fun Lesson.expandRecurrenceToday(rangeStart: Instant, rangeEnd: Instant): List<LessonForToday> {\n    val recurrence = recurrence ?: return emptyList()\n    if (rangeStart >= rangeEnd) return emptyList()\n    val occurrences = expandRecurrence(rangeStart, rangeEnd, recurrence)\n    if (occurrences.isEmpty()) return emptyList()\n    val base = toTodayStub()\n    val duration = base.duration\n    val seriesId = seriesId ?: id\n    return occurrences.map { occurrence ->\n        base.copy(\n            id = syntheticId(seriesId, occurrence),\n            baseLessonId = id,\n            startAt = occurrence,\n            endAt = occurrence.plus(duration),\n            duration = duration,\n            paidCents = 0,\n            isRecurring = true,\n            seriesId = seriesId,\n            originalStartAt = occurrence,\n            recurrenceLabel = base.recurrenceLabel\n        )\n    }\n}\n\nprivate fun expandRecurrence(\n    rangeStart: Instant,\n    rangeEnd: Instant,\n    recurrence: LessonRecurrence\n): List<Instant> {\n    val zone = recurrence.timezone\n    val base = recurrence.startDateTime.atZone(zone)\n    val effectiveEnd = recurrence.untilDateTime?.takeIf { it < rangeEnd } ?: rangeEnd\n    if (effectiveEnd <= recurrence.startDateTime) return emptyList()\n    val windowStart = rangeStart.atZone(zone)\n    val windowEnd = effectiveEnd.atZone(zone)\n    val results = mutableSetOf<Instant>()\n\n    when (recurrence.frequency) {\n        RecurrenceFrequency.MONTHLY_BY_DOW -> {\n            val monthsStep = maxOf(1, recurrence.interval)\n            val ordinal = ((base.dayOfMonth - 1) / 7) + 1\n            var monthOffset = 0\n            while (true) {\n                val candidateMonthStart = base.withDayOfMonth(1).plusMonths(monthOffset.toLong() * monthsStep)\n                var candidate = candidateMonthStart.with(\n                    TemporalAdjusters.dayOfWeekInMonth(ordinal, base.dayOfWeek)\n                )\n                candidate = candidate.withHour(base.hour)\n                    .withMinute(base.minute)\n                    .withSecond(base.second)\n                    .withNano(base.nano)\n\n                val instant = candidate.toInstant()\n                if (instant > windowEnd.toInstant()) break\n                if (candidate.isBefore(base)) {\n                    monthOffset += 1\n                    continue\n                }\n                if (instant != recurrence.startDateTime && !candidate.isBefore(windowStart) && instant < rangeEnd) {\n                    results += instant\n                }\n                monthOffset += 1\n            }\n        }\n\n        else -> {\n            val intervalWeeks = when (recurrence.frequency) {\n                RecurrenceFrequency.WEEKLY -> maxOf(1, recurrence.interval)\n                RecurrenceFrequency.BIWEEKLY -> maxOf(1, recurrence.interval) * 2\n                RecurrenceFrequency.MONTHLY_BY_DOW -> 1\n            }\n            val targetDays = if (recurrence.daysOfWeek.isEmpty()) {\n                listOf(base.dayOfWeek)\n            } else {\n                recurrence.daysOfWeek.sortedBy { it.value }\n            }\n            for (day in targetDays) {\n                var occurrence = base.with(TemporalAdjusters.nextOrSame(day))\n                if (occurrence.isBefore(base)) {\n                    occurrence = occurrence.plusWeeks(intervalWeeks.toLong())\n                }\n                while (true) {\n                    val instant = occurrence.toInstant()\n                    if (instant > windowEnd.toInstant()) break\n                    if (instant != recurrence.startDateTime) {\n                        if (!occurrence.isBefore(windowStart) && instant < rangeEnd) {\n                            results += instant\n                        }\n                    }\n                    occurrence = occurrence.plusWeeks(intervalWeeks.toLong())\n                }\n            }\n        }\n    }\n\n    return results.toList().sorted()\n}\n\nprivate fun syntheticId(seriesId: Long, start: Instant): Long {\n    val combined = (seriesId shl 1) xor start.toEpochMilli()\n    val positive = combined and Long.MAX_VALUE\n    return -(positive + 1)\n}\n\nprivate fun Lesson.toDetailsStub(): LessonDetails {\n    val duration = resolveDuration(startAt, endAt, null)\n    val normalizedEnd = startAt.plus(duration)\n    val recurrenceLabel = recurrence?.let { rule ->\n        val start = rule.startDateTime.atZone(rule.timezone)\n        RecurrenceLabelFormatter.format(rule.frequency, rule.interval, rule.daysOfWeek, start)\n    }\n\n    return LessonDetails(\n        id = id,\n        baseLessonId = id,\n        studentId = studentId,\n        startAt = startAt,\n        endAt = normalizedEnd,\n        duration = duration,\n        studentName = \"Student #$studentId\",\n        studentNote = null,\r\n        subjectName = null,\n        studentGrade = null,\n        subjectColorArgb = null,\n        paymentStatus = paymentStatus,\n        paymentStatusIcon = paymentStatus.asIcon(),\n        lessonStatus = status,\n        priceCents = priceCents,\n        paidCents = paidCents,\n        lessonTitle = title,\n        lessonNote = note,\n        isRecurring = seriesId != null,\n        seriesId = seriesId,\n        originalStartAt = startAt,\n        recurrenceLabel = recurrenceLabel\n    )\n}\n\nprivate fun Lesson.toTodayStub(): LessonForToday {\n    val duration = resolveDuration(startAt, endAt, null)\n    val normalizedEnd = startAt.plus(duration)\n    val recurrenceLabel = recurrence?.let { rule ->\n        val start = rule.startDateTime.atZone(rule.timezone)\n        RecurrenceLabelFormatter.format(rule.frequency, rule.interval, rule.daysOfWeek, start)\n    }\n\n    return LessonForToday(\n        id = id,\n        baseLessonId = id,\n        studentId = studentId,\n        studentName = \"Student #$studentId\",\n        studentGrade = null,\n        subjectName = null,\n        lessonTitle = title,\n        startAt = startAt,\n        endAt = normalizedEnd,\n        duration = duration,\n        priceCents = priceCents,\n        studentRateCents = null,\n        note = note,\n        paymentStatus = paymentStatus,\n        lessonStatus = status,\n        markedAt = markedAt,\n        isRecurring = seriesId != null,\n        seriesId = seriesId,\n        originalStartAt = startAt,\n        recurrenceLabel = recurrenceLabel\n    )\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt b/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt
--- a/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt	(revision 63eb851cc8494c68fff2aa173e7dd6f8c3e61efa)
+++ b/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt	(date 1770122068980)
@@ -9,10 +9,10 @@
 import com.tutorly.domain.repo.LessonsRepository
 import com.tutorly.models.Lesson
 import com.tutorly.domain.recurrence.RecurrenceLabelFormatter
+import com.tutorly.models.LessonRecurrence
 import com.tutorly.models.Payment
 import com.tutorly.models.PaymentStatus
 import com.tutorly.models.LessonStatus
-import com.tutorly.models.LessonRecurrence
 import com.tutorly.models.RecurrenceFrequency
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.MutableStateFlow
@@ -459,6 +459,7 @@
         isRecurring = seriesId != null,
         seriesId = seriesId,
         originalStartAt = startAt,
-        recurrenceLabel = recurrenceLabel
+        recurrenceLabel = recurrenceLabel,
+        paidCents = TODO(),
     )
 }
Index: app/src/main/java/com/tutorly/data/repo/room/RoomLessonsRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.data.repo.room\r\n\r\nimport com.tutorly.data.db.dao.LessonCountTuple\nimport com.tutorly.data.db.dao.LessonDao\nimport com.tutorly.data.db.dao.PaymentDao\nimport com.tutorly.data.db.dao.RecurrenceExceptionDao\nimport com.tutorly.data.db.dao.RecurrenceRuleDao\nimport com.tutorly.data.db.projections.LessonWithStudent\nimport com.tutorly.data.db.projections.toLessonDetails\nimport com.tutorly.domain.model.LessonCreateRequest\nimport com.tutorly.domain.model.LessonDetails\nimport com.tutorly.domain.model.LessonForToday\nimport com.tutorly.domain.model.LessonsRangeStats\nimport com.tutorly.domain.recurrence.RecurrenceLabelFormatter\nimport com.tutorly.domain.repo.LessonsRepository\nimport com.tutorly.models.Lesson\nimport com.tutorly.models.LessonStatus\nimport com.tutorly.models.LessonRecurrence\nimport com.tutorly.models.Payment\nimport com.tutorly.models.PaymentStatus\nimport com.tutorly.models.RecurrenceException\nimport com.tutorly.models.RecurrenceExceptionType\nimport com.tutorly.models.RecurrenceFrequency\nimport com.tutorly.models.RecurrenceRule\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.combine\nimport kotlinx.coroutines.flow.map\nimport java.time.Duration\nimport java.time.Instant\nimport java.time.ZoneId\nimport java.time.temporal.TemporalAdjusters\n\r\nclass RoomLessonsRepository(\n    private val lessonDao: LessonDao,\n    private val paymentDao: PaymentDao,\n    private val recurrenceRuleDao: RecurrenceRuleDao,\n    private val recurrenceExceptionDao: RecurrenceExceptionDao,\n    private val prepaymentAllocator: StudentPrepaymentAllocator\n) : LessonsRepository {\n    override fun observeLessons(from: Instant, to: Instant): Flow<List<LessonDetails>> =\n        combine(\n            lessonDao.observeInRange(from, to),\n            recurrenceRuleDao.observeAll(),\n            recurrenceExceptionDao.observeAll()\n        ) { lessons, rules, exceptions ->\n            buildLessonsInRange(\n                baseLessons = lessons,\n                rules = rules,\n                exceptions = exceptions,\n                rangeStart = from,\n                rangeEnd = to\n            ).map { it.details }\n        }\n\n    override fun observeTodayLessons(dayStart: Instant, dayEnd: Instant): Flow<List<LessonForToday>> =\n        combine(\n            lessonDao.observeInRange(dayStart, dayEnd),\n            recurrenceRuleDao.observeAll(),\n            recurrenceExceptionDao.observeAll()\n        ) { lessons, rules, exceptions ->\n            buildLessonsInRange(\n                baseLessons = lessons,\n                rules = rules,\n                exceptions = exceptions,\n                rangeStart = dayStart,\n                rangeEnd = dayEnd\n            ).map { bundle ->\n                val detail = bundle.details\n                LessonForToday(\n                    id = detail.id,\n                    baseLessonId = detail.baseLessonId,\n                    studentId = detail.studentId,\n                    studentName = detail.studentName,\n                    studentGrade = detail.studentGrade,\n                    subjectName = detail.subjectName,\n                    lessonTitle = detail.lessonTitle,\n                    startAt = detail.startAt,\n                    endAt = detail.endAt,\n                    duration = detail.duration,\n                    priceCents = detail.priceCents,\n                    studentRateCents = bundle.studentRateCents,\n                    note = detail.lessonNote,\n                    paymentStatus = detail.paymentStatus,\n                    lessonStatus = detail.lessonStatus,\n                    markedAt = bundle.markedAt,\n                    isRecurring = detail.isRecurring,\n                    seriesId = detail.seriesId,\n                    originalStartAt = detail.originalStartAt,\n                    recurrenceLabel = detail.recurrenceLabel\n                )\n            }\n        }\n\n    override fun observeOutstandingLessons(before: Instant): Flow<List<LessonForToday>> =\n        combine(\n            lessonDao.observeOutstanding(before, PaymentStatus.outstandingStatuses),\n            recurrenceRuleDao.observeAll(),\n            recurrenceExceptionDao.observeAll()\n        ) { lessons, rules, exceptions ->\n            buildLessonsInRange(\n                baseLessons = lessons,\n                rules = rules,\n                exceptions = exceptions,\n                rangeStart = Instant.EPOCH,\n                rangeEnd = before\n            ).map { bundle ->\n                val detail = bundle.details\n                LessonForToday(\n                    id = detail.id,\n                    baseLessonId = detail.baseLessonId,\n                    studentId = detail.studentId,\n                    studentName = detail.studentName,\n                    studentGrade = detail.studentGrade,\n                    subjectName = detail.subjectName,\n                    lessonTitle = detail.lessonTitle,\n                    startAt = detail.startAt,\n                    endAt = detail.endAt,\n                    duration = detail.duration,\n                    priceCents = detail.priceCents,\n                    studentRateCents = bundle.studentRateCents,\n                    note = detail.lessonNote,\n                    paymentStatus = detail.paymentStatus,\n                    lessonStatus = detail.lessonStatus,\n                    markedAt = bundle.markedAt,\n                    isRecurring = detail.isRecurring,\n                    seriesId = detail.seriesId,\n                    originalStartAt = detail.originalStartAt,\n                    recurrenceLabel = detail.recurrenceLabel\n                )\n            }\n        }\n\n    override fun observeOutstandingLessonDetails(before: Instant): Flow<List<LessonDetails>> =\n        combine(\n            lessonDao.observeOutstanding(before, PaymentStatus.outstandingStatuses),\n            recurrenceRuleDao.observeAll(),\n            recurrenceExceptionDao.observeAll()\n        ) { lessons, rules, exceptions ->\n            buildLessonsInRange(\n                baseLessons = lessons,\n                rules = rules,\n                exceptions = exceptions,\n                rangeStart = Instant.EPOCH,\n                rangeEnd = before\n            ).map { it.details }\n        }\n\n    override fun observeWeekStats(from: Instant, to: Instant): Flow<LessonsRangeStats> =\n        combine(\n            lessonDao.observeLessonCounts(\r\n                from = from,\r\n                to = to,\r\n                paidStatus = PaymentStatus.PAID,\r\n                outstandingStatuses = PaymentStatus.outstandingStatuses\r\n            ),\r\n            paymentDao.observeTotalInRange(\r\n                from = from,\r\n                to = to,\r\n                status = PaymentStatus.PAID\r\n            )\r\n        ) { counts: LessonCountTuple, earned ->\r\n            LessonsRangeStats(\r\n                totalLessons = counts.totalLessons,\r\n                paidLessons = counts.paidLessons,\r\n                debtLessons = counts.debtLessons,\r\n                earnedCents = earned\r\n            )\n        }\n\n    override fun observeLessonDetails(id: Long): Flow<LessonDetails?> =\n        combine(\n            lessonDao.observeById(id),\n            recurrenceRuleDao.observeAll()\n        ) { lesson, rules ->\n            lesson?.let { projection ->\n                val details = projection.toLessonDetails()\n                val resolvedRule = details.seriesId?.let { seriesId ->\n                    rules.firstOrNull { rule -> rule.id == seriesId }\n                } ?: rules.firstOrNull { rule -> rule.baseLessonId == details.baseLessonId }\n                val label = resolvedRule?.let { rule -> RecurrenceLabelFormatter.format(rule) }\n                details.copy(\n                    isRecurring = resolvedRule != null,\n                    seriesId = resolvedRule?.id ?: details.seriesId,\n                    recurrenceLabel = label\n                )\n            }\n        }\n\n    override fun observeByStudent(studentId: Long): Flow<List<Lesson>> =\n        combine(\n            lessonDao.observeByStudent(studentId),\n            recurrenceRuleDao.observeAll()\n        ) { lessons, rules ->\n            attachRecurrence(lessons, rules)\n        }\n\n    override suspend fun getById(id: Long): Lesson? {\n        val lesson = lessonDao.findById(id) ?: return null\n        val rule = loadRuleForLesson(lesson)\n        val normalized = ensureSeriesLink(lesson, rule)\n        return normalized.copy(recurrence = rule?.toLessonRecurrence())\n    }\n\n    override suspend fun upsert(lesson: Lesson): Long {\n        val existing = lesson.id.takeIf { it != 0L }?.let { lessonDao.findById(it) }\n        val id = lessonDao.upsert(lesson)\n        val baseLessonId = if (lesson.id == 0L) id else lesson.id\n        val recurrence = lesson.recurrence\n        when {\n            recurrence != null -> {\n                val targetRuleId = lesson.seriesId ?: existing?.seriesId ?: 0L\n                val ruleId = recurrenceRuleDao.upsert(\n                    RecurrenceRule(\n                        id = targetRuleId,\n                        baseLessonId = baseLessonId,\n                        frequency = recurrence.frequency,\n                        interval = recurrence.interval,\n                        daysOfWeek = recurrence.daysOfWeek,\n                        startDateTime = recurrence.startDateTime,\n                        untilDateTime = recurrence.untilDateTime,\n                        timezone = recurrence.timezone.id\n                    )\n                )\n                if (lesson.seriesId == null || lesson.seriesId != ruleId) {\n                    val refreshed = lesson.copy(\n                        id = baseLessonId,\n                        seriesId = ruleId,\n                        updatedAt = Instant.now()\n                    )\n                    lessonDao.upsert(refreshed)\n                }\n                val anchor = lessonDao.findById(baseLessonId)\n                val rule = recurrenceRuleDao.findById(ruleId)\n                if (anchor != null && rule != null) {\n                    val normalizedAnchor = ensureSeriesLink(anchor, rule)\n                    generateFutureOccurrences(normalizedAnchor, rule)\n                }\n            }\n\n            existing?.seriesId != null && lesson.seriesId == null -> {\n                recurrenceRuleDao.deleteById(existing.seriesId)\n                lessonDao.deleteInstancesForSeries(existing.seriesId)\n            }\n        }\n        prepaymentAllocator.sync(lesson.studentId)\n        return baseLessonId\n    }\n\n    override suspend fun create(request: LessonCreateRequest): Long {\n        val now = Instant.now()\r\n        var lesson = Lesson(\n            studentId = request.studentId,\n            subjectId = request.subjectId,\n            title = request.title,\n            startAt = request.startAt,\n            endAt = request.endAt,\n            priceCents = request.priceCents,\r\n            paidCents = 0,\r\n            paymentStatus = PaymentStatus.UNPAID,\n            markedAt = null,\n            status = LessonStatus.PLANNED,\n            note = request.note,\r\n            createdAt = now,\r\n            updatedAt = now\r\n        )\r\n        val id = lessonDao.upsert(lesson)\n        val recurrenceRequest = request.recurrence\n        if (recurrenceRequest != null) {\n            val ruleId = recurrenceRuleDao.upsert(\n                RecurrenceRule(\n                    baseLessonId = id,\n                    frequency = recurrenceRequest.frequency,\n                    interval = recurrenceRequest.interval,\n                    daysOfWeek = recurrenceRequest.daysOfWeek,\n                    startDateTime = request.startAt,\n                    untilDateTime = recurrenceRequest.until,\n                    timezone = recurrenceRequest.timezone.id\n                )\n            )\n            lesson = lesson.copy(id = id, seriesId = ruleId, updatedAt = Instant.now())\n            lessonDao.upsert(lesson)\n            val rule = recurrenceRuleDao.findById(ruleId)\n            if (rule != null) {\n                generateFutureOccurrences(lesson, rule)\n            }\n        }\n        prepaymentAllocator.sync(lesson.studentId)\n        return id\n    }\n\n    override suspend fun moveLesson(lessonId: Long, newStart: Instant, newEnd: Instant) {\n        val existing = lessonDao.findById(lessonId) ?: return\n        val updated = existing.copy(\n            startAt = newStart,\n            endAt = newEnd,\n            updatedAt = Instant.now()\n        )\n        lessonDao.upsert(updated)\n        if (updated.seriesId != null) {\n            val rule = recurrenceRuleDao.findById(updated.seriesId)\n            if (rule != null) {\n                recurrenceRuleDao.upsert(\n                    rule.copy(\n                        startDateTime = newStart,\n                        untilDateTime = rule.untilDateTime\n                    )\n                )\n            }\n            recurrenceExceptionDao.deleteInstance(updated.seriesId, existing.startAt)\n        }\n    }\n\n    override suspend fun moveRecurringOccurrence(\n        seriesId: Long,\n        originalStart: Instant,\n        newStart: Instant,\n        duration: Duration\n    ) {\n        val minutes = duration.toMinutes().toInt().coerceAtLeast(0)\n        val exception = RecurrenceException(\n            seriesId = seriesId,\n            originalDateTime = originalStart,\n            type = RecurrenceExceptionType.OVERRIDDEN,\n            overrideStartDateTime = newStart,\n            overrideDurationMinutes = minutes.takeIf { it > 0 },\n            overrideNotes = null,\n            overridePrice = null\n        )\n        recurrenceExceptionDao.upsert(exception)\n    }\n\n    override suspend fun clearRecurringOverride(seriesId: Long, originalStart: Instant) {\n        recurrenceExceptionDao.deleteInstance(seriesId, originalStart)\n    }\n\r\n    override suspend fun findConflicts(start: Instant, end: Instant): List<LessonDetails> {\r\n        return lessonDao.findOverlapping(start, end).map { it.toLessonDetails() }\r\n    }\r\n\r\n    override suspend fun latestLessonForStudent(studentId: Long): Lesson? {\n        val projection = lessonDao.findLatestForStudent(studentId) ?: return null\n        val lesson = projection.lesson\n        val rule = loadRuleForLesson(lesson)\n        val normalized = ensureSeriesLink(lesson, rule)\n        return normalized.copy(recurrence = rule?.toLessonRecurrence())\n    }\n\n    override suspend fun delete(id: Long) {\n        val lesson = lessonDao.findById(id)\n        lessonDao.deleteById(id)\n        if (lesson != null) {\n            prepaymentAllocator.sync(lesson.studentId)\n        }\n    }\n\n    override suspend fun markPaid(id: Long) {\n        val lesson = lessonDao.findById(id) ?: return\n        val now = Instant.now()\n        lessonDao.updatePayment(id, PaymentStatus.PAID, lesson.priceCents, now, now)\n\n        val existing = paymentDao.findByLesson(id)\r\n        val payment = (existing ?: Payment(\r\n            lessonId = lesson.id,\r\n            studentId = lesson.studentId,\r\n            amountCents = lesson.priceCents,\r\n            status = PaymentStatus.PAID,\r\n            at = now\r\n        )).copy(\r\n            amountCents = lesson.priceCents,\r\n            status = PaymentStatus.PAID,\r\n            at = now\r\n        )\r\n\r\n        if (existing == null) {\r\n            paymentDao.insert(payment)\r\n        } else {\r\n            paymentDao.update(payment)\r\n        }\r\n    }\r\n\r\n    override suspend fun markDue(id: Long) {\r\n        val lesson = lessonDao.findById(id) ?: return\r\n        val now = Instant.now()\r\n        lessonDao.updatePayment(id, PaymentStatus.DUE, 0, now, now)\n\r\n        val existing = paymentDao.findByLesson(id)\r\n        val payment = (existing ?: Payment(\r\n            lessonId = lesson.id,\r\n            studentId = lesson.studentId,\r\n            amountCents = lesson.priceCents,\r\n            status = PaymentStatus.DUE,\r\n            at = now\r\n        )).copy(\r\n            amountCents = lesson.priceCents,\r\n            status = PaymentStatus.DUE,\r\n            at = now\r\n        )\r\n\r\n        if (existing == null) {\r\n            paymentDao.insert(payment)\r\n        } else {\r\n            paymentDao.update(payment)\r\n        }\r\n    }\r\n\r\n    override suspend fun saveNote(id: Long, note: String?) =\n        lessonDao.updateNote(id, note, Instant.now())\n\n    override suspend fun resetPaymentStatus(id: Long) {\n        val lesson = lessonDao.findById(id) ?: return\n        val now = Instant.now()\n        lessonDao.updatePayment(id, PaymentStatus.UNPAID, 0, now, null)\n\n        val existing = paymentDao.findByLesson(id)\n        if (existing != null) {\n            paymentDao.delete(existing)\n        }\n    }\n\n    private suspend fun buildLessonsInRange(\n        baseLessons: List<LessonWithStudent>,\n        rules: List<RecurrenceRule>,\n        exceptions: List<RecurrenceException>,\n        rangeStart: Instant,\n        rangeEnd: Instant\n    ): List<LessonBundle> {\n        val storedStartsBySeries = baseLessons\n            .filter { it.lesson.seriesId != null && it.lesson.isInstance }\n            .groupBy { it.lesson.seriesId!! }\n            .mapValues { entry -> entry.value.map { it.lesson.startAt }.toSet() }\n        val baseBundles = baseLessons.map { lesson ->\n            LessonBundle(\n                details = lesson.toLessonDetails(),\n                studentRateCents = lesson.student.rateCents,\n                markedAt = lesson.lesson.markedAt\n            )\n        }\n        if (rules.isEmpty()) {\n            return baseBundles.sortedBy { it.details.startAt }\n        }\n\n        val activeRules = rules.filter { rule ->\n            rule.startDateTime < rangeEnd && (rule.untilDateTime == null || rule.untilDateTime >= rangeStart)\n        }\n        if (activeRules.isEmpty()) {\n            return baseBundles.sortedBy { it.details.startAt }\n        }\n\n        val ruleById = activeRules.associateBy { it.id }\n        val ruleByBase = activeRules.associateBy { it.baseLessonId }\n        val labelBySeries = ruleById.mapValues { (_, rule) -> RecurrenceLabelFormatter.format(rule) }\n        val normalizedBase = baseBundles.map { bundle ->\n            val detail = bundle.details\n            val rule = detail.seriesId?.let { ruleById[it] } ?: ruleByBase[detail.baseLessonId]\n            if (rule != null) {\n                val label = labelBySeries[rule.id]\n                bundle.copy(\n                    details = detail.copy(\n                        baseLessonId = rule.baseLessonId,\n                        isRecurring = true,\n                        seriesId = rule.id,\n                        recurrenceLabel = label,\n                        originalStartAt = detail.originalStartAt ?: detail.startAt\n                    )\n                )\n            } else {\n                bundle\n            }\n        }\n        val baseByLessonId = normalizedBase.associateBy { it.details.baseLessonId }\n\n        val exceptionsBySeries = exceptions.groupBy { it.seriesId }\n        val generated = mutableListOf<LessonBundle>()\n\n        for (rule in activeRules) {\n            val templateBundle = baseByLessonId[rule.baseLessonId]\n                ?: lessonDao.findByIdWithStudent(rule.baseLessonId)?.let { base ->\n                    val detail = base.toLessonDetails()\n                    val normalizedDetail = detail.copy(\n                        isRecurring = true,\n                        seriesId = rule.id,\n                        recurrenceLabel = labelBySeries[rule.id],\n                        originalStartAt = detail.originalStartAt ?: detail.startAt\n                    )\n                    LessonBundle(\n                        details = normalizedDetail,\n                        studentRateCents = base.student.rateCents,\n                        markedAt = base.lesson.markedAt\n                    )\n                }\n                ?: continue\n\n            val occurrences = expandSeries(rule, rangeStart, rangeEnd)\n            val storedStarts = storedStartsBySeries[rule.id].orEmpty()\n            val filteredOccurrences = occurrences.filter { it !in storedStarts }\n            if (filteredOccurrences.isEmpty()) continue\n\n            val applied = applyExceptions(\n                template = templateBundle.details,\n                rule = rule,\n                occurrences = filteredOccurrences,\n                exceptions = exceptionsBySeries[rule.id].orEmpty(),\n                rangeStart = rangeStart,\n                rangeEnd = rangeEnd\n            ).map { detail ->\n                LessonBundle(\n                    details = detail,\n                    studentRateCents = templateBundle.studentRateCents,\n                    markedAt = null\n                )\n            }\n            generated += applied\n        }\n\n        return (normalizedBase + generated).sortedBy { it.details.startAt }\n    }\n\n    private fun expandSeries(\n        rule: RecurrenceRule,\n        rangeStart: Instant,\n        rangeEnd: Instant\n    ): List<Instant> {\n        if (rangeStart >= rangeEnd) return emptyList()\n        val zone = runCatching { ZoneId.of(rule.timezone) }.getOrDefault(ZoneId.systemDefault())\n        val base = rule.startDateTime.atZone(zone)\n        val effectiveEndInstant = rule.untilDateTime?.takeIf { it < rangeEnd } ?: rangeEnd\n        if (effectiveEndInstant <= rule.startDateTime) return emptyList()\n        val windowStart = rangeStart.atZone(zone)\n        val windowEnd = effectiveEndInstant.atZone(zone)\n        val results = mutableSetOf<Instant>()\n\n        when (rule.frequency) {\n            RecurrenceFrequency.MONTHLY_BY_DOW -> {\n                val monthsStep = maxOf(1, rule.interval)\n                val ordinal = ((base.dayOfMonth - 1) / 7) + 1\n                var monthOffset = 0\n                while (true) {\n                    val candidateMonthStart = base.withDayOfMonth(1).plusMonths(monthOffset.toLong() * monthsStep)\n                    var candidate = candidateMonthStart.with(\n                        TemporalAdjusters.dayOfWeekInMonth(ordinal, base.dayOfWeek)\n                    )\n                    candidate = candidate.withHour(base.hour)\n                        .withMinute(base.minute)\n                        .withSecond(base.second)\n                        .withNano(base.nano)\n\n                    val instant = candidate.toInstant()\n                    if (instant > windowEnd.toInstant()) break\n                    if (candidate.isBefore(base)) {\n                        monthOffset += 1\n                        continue\n                    }\n                    if (instant != rule.startDateTime && !candidate.isBefore(windowStart) && instant < rangeEnd) {\n                        results += instant\n                    }\n                    monthOffset += 1\n                }\n            }\n            else -> {\n                val intervalWeeks = when (rule.frequency) {\n                    RecurrenceFrequency.WEEKLY -> maxOf(1, rule.interval)\n                    RecurrenceFrequency.BIWEEKLY -> maxOf(1, rule.interval) * 2\n                    RecurrenceFrequency.MONTHLY_BY_DOW -> 1 // unreachable\n                }\n                val targetDays = if (rule.daysOfWeek.isEmpty()) {\n                    listOf(base.dayOfWeek)\n                } else {\n                    rule.daysOfWeek.sortedBy { it.value }\n                }\n                for (day in targetDays) {\n                    var occurrence = base.with(TemporalAdjusters.nextOrSame(day))\n                    if (occurrence.isBefore(base)) {\n                        occurrence = occurrence.plusWeeks(intervalWeeks.toLong())\n                    }\n                    while (true) {\n                        val instant = occurrence.toInstant()\n                        if (instant > windowEnd.toInstant()) break\n                        if (instant != rule.startDateTime) {\n                            if (!occurrence.isBefore(windowStart) && instant < rangeEnd) {\n                                results += instant\n                            }\n                        }\n                        occurrence = occurrence.plusWeeks(intervalWeeks.toLong())\n                    }\n                }\n            }\n        }\n\n        return results.toList().sorted()\n    }\n\n    private fun applyExceptions(\n        template: LessonDetails,\n        rule: RecurrenceRule,\n        occurrences: List<Instant>,\n        exceptions: List<RecurrenceException>,\n        rangeStart: Instant,\n        rangeEnd: Instant\n    ): List<LessonDetails> {\n        if (occurrences.isEmpty()) return emptyList()\n        val exceptionByOriginal = exceptions.associateBy { it.originalDateTime }\n        val label = RecurrenceLabelFormatter.format(rule)\n        val results = mutableListOf<LessonDetails>()\n\n        for (occurrence in occurrences) {\n            val exception = exceptionByOriginal[occurrence]\n            if (exception?.type == RecurrenceExceptionType.CANCELLED) {\n                continue\n            }\n            val actualStart = exception?.overrideStartDateTime ?: occurrence\n            if (actualStart < rangeStart || actualStart >= rangeEnd) continue\n            val duration = exception?.overrideDurationMinutes\n                ?.takeIf { it > 0 }\n                ?.let { Duration.ofMinutes(it.toLong()) }\n                ?: template.duration\n            val actualEnd = actualStart.plus(duration)\n            val note = exception?.overrideNotes ?: template.lessonNote\n            val price = exception?.overridePrice ?: template.priceCents\n\n            results += template.copy(\n                id = syntheticId(rule.id, actualStart),\n                startAt = actualStart,\n                endAt = actualEnd,\n                duration = duration,\n                priceCents = price,\n                paidCents = 0,\n                lessonNote = note,\n                isRecurring = true,\n                seriesId = rule.id,\n                originalStartAt = occurrence,\n                recurrenceLabel = label\n            )\n        }\n\n        return results\n    }\n\n    private fun attachRecurrence(\n        lessons: List<Lesson>,\n        rules: List<RecurrenceRule>\n    ): List<Lesson> {\n        if (lessons.isEmpty()) return emptyList()\n        if (rules.isEmpty()) return lessons.map { it.copy(recurrence = null) }\n\n        val ruleById = rules.associateBy { it.id }\n        val ruleByBase = rules.associateBy { it.baseLessonId }\n        return lessons.map { lesson ->\n            val rule = lesson.seriesId?.let { seriesId ->\n                ruleById[seriesId]\n            } ?: ruleByBase[lesson.id]\n            val recurrence = rule?.toLessonRecurrence()\n            val seriesId = rule?.id ?: lesson.seriesId\n            lesson.copy(seriesId = seriesId, recurrence = recurrence)\n        }\n    }\n\n    private suspend fun generateFutureOccurrences(\n        baseLesson: Lesson,\n        rule: RecurrenceRule\n    ) {\n        val existingInstances = lessonDao.listInstancesForSeries(rule.id)\n        val now = Instant.now()\n        val horizon = determineGenerationHorizon(baseLesson.startAt, rule, now)\n        if (horizon <= now) {\n            existingInstances\n                .filter { it.startAt >= now }\n                .forEach { lessonDao.deleteById(it.id) }\n            return\n        }\n\n        val occurrences = expandSeries(rule, baseLesson.startAt, horizon)\n            .filter { it >= now }\n        if (occurrences.isEmpty()) {\n            existingInstances\n                .filter { it.startAt >= now }\n                .forEach { lessonDao.deleteById(it.id) }\n            return\n        }\n\n        val limited = occurrences.take(DEFAULT_GENERATED_OCCURRENCES)\n        val desiredStarts = limited.toSet()\n        existingInstances\n            .filter { it.startAt >= now && it.startAt !in desiredStarts }\n            .forEach { lessonDao.deleteById(it.id) }\n\n        val existingByStart = existingInstances.associateBy { it.startAt }\n        val duration = resolveBaseDuration(baseLesson)\n        val timestamp = Instant.now()\n        for (start in limited) {\n            val desiredEnd = start.plus(duration)\n            val existing = existingByStart[start]\n            if (existing != null) {\n                val updated = existing.copy(\n                    studentId = baseLesson.studentId,\n                    subjectId = baseLesson.subjectId,\n                    title = baseLesson.title,\n                    endAt = desiredEnd,\n                    priceCents = baseLesson.priceCents,\n                    note = baseLesson.note,\n                    updatedAt = timestamp\n                )\n                lessonDao.upsert(updated)\n                continue\n            }\n            val instance = Lesson(\n                studentId = baseLesson.studentId,\n                subjectId = baseLesson.subjectId,\n                title = baseLesson.title,\n                startAt = start,\n                endAt = desiredEnd,\n                priceCents = baseLesson.priceCents,\n                paidCents = 0,\n                paymentStatus = PaymentStatus.UNPAID,\n                markedAt = null,\n                status = LessonStatus.PLANNED,\n                note = baseLesson.note,\n                createdAt = timestamp,\n                updatedAt = timestamp,\n                canceledAt = null,\n                seriesId = rule.id,\n                isInstance = true,\n                recurrence = null\n            )\n            lessonDao.upsert(instance)\n        }\n    }\n\n    private suspend fun loadRuleForLesson(lesson: Lesson): RecurrenceRule? {\n        lesson.seriesId?.let { seriesId ->\n            recurrenceRuleDao.findById(seriesId)?.let { return it }\n        }\n        return recurrenceRuleDao.findByBaseLessonId(lesson.id)\n    }\n\n    private suspend fun ensureSeriesLink(lesson: Lesson, rule: RecurrenceRule?): Lesson {\n        if (rule == null) return lesson\n        if (lesson.seriesId == rule.id) return lesson\n        val updated = lesson.copy(seriesId = rule.id)\n        lessonDao.upsert(updated)\n        return updated\n    }\n\n    private fun determineGenerationHorizon(baseStart: Instant, rule: RecurrenceRule, now: Instant): Instant {\n        val baseline = if (baseStart.isAfter(now)) baseStart else now\n        val defaultHorizon = baseline.plus(Duration.ofDays(DEFAULT_GENERATION_WEEKS * 7))\n        val until = rule.untilDateTime ?: return defaultHorizon\n        return if (until.isBefore(defaultHorizon)) until else defaultHorizon\n    }\n\n    private fun resolveBaseDuration(lesson: Lesson): Duration {\n        val duration = Duration.between(lesson.startAt, lesson.endAt)\n        if (!duration.isNegative && !duration.isZero) return duration\n        return Duration.ofMinutes(DEFAULT_LESSON_DURATION_MINUTES)\n    }\n\n    private fun RecurrenceRule.toLessonRecurrence(): LessonRecurrence {\n        val zone = runCatching { ZoneId.of(timezone) }.getOrDefault(ZoneId.systemDefault())\n        return LessonRecurrence(\n            frequency = frequency,\n            interval = interval,\n            daysOfWeek = daysOfWeek,\n            startDateTime = startDateTime,\n            untilDateTime = untilDateTime,\n            timezone = zone\n        )\n    }\n\n    private fun syntheticId(seriesId: Long, start: Instant): Long {\n        val combined = (seriesId shl 1) xor start.toEpochMilli()\n        val positive = combined and Long.MAX_VALUE\n        return -(positive + 1)\n    }\n\n    private data class LessonBundle(\n        val details: LessonDetails,\n        val studentRateCents: Int?,\n        val markedAt: Instant?\n    )\n\n    private companion object {\n        private const val DEFAULT_GENERATION_WEEKS = 12L\n        private const val DEFAULT_GENERATED_OCCURRENCES = 12\n        private const val DEFAULT_LESSON_DURATION_MINUTES = 60L\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/data/repo/room/RoomLessonsRepository.kt b/app/src/main/java/com/tutorly/data/repo/room/RoomLessonsRepository.kt
--- a/app/src/main/java/com/tutorly/data/repo/room/RoomLessonsRepository.kt	(revision 63eb851cc8494c68fff2aa173e7dd6f8c3e61efa)
+++ b/app/src/main/java/com/tutorly/data/repo/room/RoomLessonsRepository.kt	(date 1770122107517)
@@ -24,7 +24,6 @@
 import com.tutorly.models.RecurrenceRule
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.combine
-import kotlinx.coroutines.flow.map
 import java.time.Duration
 import java.time.Instant
 import java.time.ZoneId
@@ -86,7 +85,8 @@
                     isRecurring = detail.isRecurring,
                     seriesId = detail.seriesId,
                     originalStartAt = detail.originalStartAt,
-                    recurrenceLabel = detail.recurrenceLabel
+                    recurrenceLabel = detail.recurrenceLabel,
+                    paidCents = TODO(),
                 )
             }
         }
@@ -125,7 +125,8 @@
                     isRecurring = detail.isRecurring,
                     seriesId = detail.seriesId,
                     originalStartAt = detail.originalStartAt,
-                    recurrenceLabel = detail.recurrenceLabel
+                    recurrenceLabel = detail.recurrenceLabel,
+                    paidCents = TODO(),
                 )
             }
         }
Index: app/src/main/java/com/tutorly/domain/model/LessonForToday.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.domain.model\r\n\r\nimport com.tutorly.models.LessonStatus\r\nimport com.tutorly.models.PaymentStatus\r\nimport java.time.Duration\r\nimport java.time.Instant\r\n\r\n/**\r\n * Lightweight payload for the \"\" summary screen. Combines lesson, student and\r\n * payment fields required to render swipe actions and the note editor.\r\n */\r\ndata class LessonForToday(\r\n    val id: Long,\r\n    val baseLessonId: Long,\r\n    val studentId: Long,\r\n    val studentName: String,\r\n    val studentGrade: String?,\r\n    val subjectName: String?,\r\n    val lessonTitle: String?,\r\n    val startAt: Instant,\r\n    val endAt: Instant,\r\n    val duration: Duration,\r\n    val priceCents: Int,\r\n    val studentRateCents: Int?,\r\n    val note: String?,\r\n    val paymentStatus: PaymentStatus,\r\n    val lessonStatus: LessonStatus,\r\n    val markedAt: Instant?,\r\n    val isRecurring: Boolean,\r\n    val seriesId: Long?,\r\n    val originalStartAt: Instant?,\r\n    val recurrenceLabel: String?\r\n)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/domain/model/LessonForToday.kt b/app/src/main/java/com/tutorly/domain/model/LessonForToday.kt
--- a/app/src/main/java/com/tutorly/domain/model/LessonForToday.kt	(revision 63eb851cc8494c68fff2aa173e7dd6f8c3e61efa)
+++ b/app/src/main/java/com/tutorly/domain/model/LessonForToday.kt	(date 1770122068973)
@@ -29,5 +29,6 @@
     val isRecurring: Boolean,
     val seriesId: Long?,
     val originalStartAt: Instant?,
-    val recurrenceLabel: String?
+    val recurrenceLabel: String?,
+    val paidCents: Int
 )
Index: app/src/main/java/com/tutorly/data/db/projections/LessonWithStudent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.data.db.projections\r\n\r\nimport androidx.room.Embedded\r\nimport androidx.room.Relation\r\nimport com.tutorly.domain.model.LessonDetails\nimport com.tutorly.domain.model.LessonForToday\nimport com.tutorly.domain.model.asIcon\nimport com.tutorly.domain.model.resolveDuration\nimport com.tutorly.models.Lesson\nimport com.tutorly.models.Payment\nimport com.tutorly.models.Student\nimport com.tutorly.models.SubjectPreset\n\r\ndata class LessonWithStudent(\n    @Embedded val lesson: Lesson,\n    @Relation(parentColumn = \"studentId\", entityColumn = \"id\")\n    val student: Student,\n    @Relation(parentColumn = \"subjectId\", entityColumn = \"id\")\n    val subject: SubjectPreset?,\n    @Relation(parentColumn = \"id\", entityColumn = \"lessonId\")\n    val payments: List<Payment>\n)\n\ndata class LessonWithSubject(\n    @Embedded val lesson: Lesson,\n    @Relation(parentColumn = \"subjectId\", entityColumn = \"id\")\n    val subject: SubjectPreset?\n)\n\nfun LessonWithStudent.toLessonDetails(): LessonDetails {\n    val normalizedDuration = resolveDuration(\n        startAt = lesson.startAt,\n        endAt = lesson.endAt,\n        subjectDurationMinutes = subject?.durationMinutes\n    )\n    val normalizedEnd = lesson.startAt.plus(normalizedDuration)\n\n    val subjectName = subject?.name?.takeIf { it.isNotBlank() }?.trim()\n        ?: student.subject?.takeIf { it.isNotBlank() }?.trim()\n\n    return LessonDetails(\n        id = lesson.id,\n        baseLessonId = lesson.id,\n        studentId = lesson.studentId,\n        startAt = lesson.startAt,\n        endAt = normalizedEnd,\n        duration = normalizedDuration,\n        studentName = student.name,\n        studentNote = student.note,\n        subjectName = subjectName,\n        studentGrade = student.grade,\n        subjectColorArgb = subject?.colorArgb,\n        paymentStatus = lesson.paymentStatus,\n        paymentStatusIcon = lesson.paymentStatus.asIcon(),\n        lessonStatus = lesson.status,\n        priceCents = lesson.priceCents,\n        paidCents = lesson.paidCents,\n        lessonTitle = lesson.title,\n        lessonNote = lesson.note,\n        isRecurring = lesson.seriesId != null,\n        seriesId = lesson.seriesId,\n        originalStartAt = lesson.startAt\n    )\n}\n\nfun LessonWithStudent.toLessonForToday(): LessonForToday {\n    val normalizedDuration = resolveDuration(\n        startAt = lesson.startAt,\n        endAt = lesson.endAt,\n        subjectDurationMinutes = subject?.durationMinutes\n    )\n    val normalizedEnd = lesson.startAt.plus(normalizedDuration)\n\n    val subjectName = subject?.name?.takeIf { it.isNotBlank() }?.trim()\n        ?: student.subject?.takeIf { it.isNotBlank() }?.trim()\n\n    return LessonForToday(\n        id = lesson.id,\n        baseLessonId = lesson.id,\n        studentId = lesson.studentId,\n        studentName = student.name,\n        studentGrade = student.grade,\n        subjectName = subjectName,\n        lessonTitle = lesson.title,\n        startAt = lesson.startAt,\n        endAt = normalizedEnd,\n        duration = normalizedDuration,\n        priceCents = lesson.priceCents,\n        studentRateCents = student.rateCents,\n        note = lesson.note,\n        paymentStatus = lesson.paymentStatus,\n        lessonStatus = lesson.status,\n        markedAt = lesson.markedAt,\n        isRecurring = lesson.seriesId != null,\n        seriesId = lesson.seriesId,\n        originalStartAt = lesson.startAt,\n        recurrenceLabel = null\n    )\n}\n\r\ndata class StudentWithLessons(\r\n    @Embedded val student: Student,\r\n    @Relation(parentColumn = \"id\", entityColumn = \"studentId\")\r\n    val lessons: List<Lesson>\r\n)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/data/db/projections/LessonWithStudent.kt b/app/src/main/java/com/tutorly/data/db/projections/LessonWithStudent.kt
--- a/app/src/main/java/com/tutorly/data/db/projections/LessonWithStudent.kt	(revision 63eb851cc8494c68fff2aa173e7dd6f8c3e61efa)
+++ b/app/src/main/java/com/tutorly/data/db/projections/LessonWithStudent.kt	(date 1770122084118)
@@ -94,7 +94,8 @@
         isRecurring = lesson.seriesId != null,
         seriesId = lesson.seriesId,
         originalStartAt = lesson.startAt,
-        recurrenceLabel = null
+        recurrenceLabel = null,
+        paidCents = TODO(),
     )
 }
 
