Index: app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.tutorly.data.repo.memory\r\n\r\nimport com.tutorly.domain.model.LessonCreateRequest\r\nimport com.tutorly.domain.model.LessonDetails\r\nimport com.tutorly.domain.model.LessonForToday\nimport com.tutorly.domain.model.LessonsRangeStats\nimport com.tutorly.domain.model.asIcon\r\nimport com.tutorly.domain.model.resolveDuration\r\nimport com.tutorly.domain.repo.LessonsRepository\r\nimport com.tutorly.models.Lesson\r\nimport com.tutorly.domain.recurrence.RecurrenceLabelFormatter\nimport com.tutorly.models.Payment\nimport com.tutorly.models.PaymentStatus\r\nimport com.tutorly.models.LessonStatus\r\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.map\nimport java.time.Duration\nimport java.time.Instant\nimport java.util.concurrent.ConcurrentHashMap\r\nimport java.util.concurrent.atomic.AtomicLong\r\n\r\nclass InMemoryLessonsRepository : LessonsRepository {\r\n    private val seq = AtomicLong(1)\n    private val recurrenceSeq = AtomicLong(1)\n    private val store = ConcurrentHashMap<Long, Lesson>()\r\n    private val lessonsFlow = MutableStateFlow<List<Lesson>>(emptyList())\r\n    private val payments = ConcurrentHashMap<Long, Payment>()\r\n\r\n    override fun observeLessons(from: Instant, to: Instant): Flow<List<LessonDetails>> =\n        lessonsFlow.map { lessons ->\n            lessons.filter { it.startAt >= from && it.startAt < to }\n                .sortedBy { it.startAt }\n                .map { it.toDetailsStub() }\n        }\n\n    override fun observeTodayLessons(dayStart: Instant, dayEnd: Instant): Flow<List<LessonForToday>> =\n        lessonsFlow.map { lessons ->\n            lessons.filter { it.startAt >= dayStart && it.startAt < dayEnd }\n                .sortedBy { it.startAt }\n                .map { it.toTodayStub() }\n        }\n\n    override fun observeOutstandingLessons(before: Instant): Flow<List<LessonForToday>> =\n        lessonsFlow.map { lessons ->\n            lessons.filter { it.startAt < before && it.paymentStatus in PaymentStatus.outstandingStatuses }\n                .sortedBy { it.startAt }\n                .map { it.toTodayStub() }\n        }\n\n    override fun observeOutstandingLessonDetails(before: Instant): Flow<List<LessonDetails>> =\n        lessonsFlow.map { lessons ->\n            lessons.filter { it.startAt < before && it.paymentStatus in PaymentStatus.outstandingStatuses }\n                .sortedBy { it.startAt }\n                .map { it.toDetailsStub() }\n        }\n\n    override fun observeWeekStats(from: Instant, to: Instant): Flow<LessonsRangeStats> =\r\n        lessonsFlow.map { lessons ->\r\n            val relevant = lessons.filter { it.startAt >= from && it.startAt < to }\r\n            val paidStatus = PaymentStatus.PAID\r\n            val outstanding = PaymentStatus.outstandingStatuses.toSet()\r\n            LessonsRangeStats(\r\n                totalLessons = relevant.size,\r\n                paidLessons = relevant.count { it.paymentStatus == paidStatus },\r\n                debtLessons = relevant.count { it.paymentStatus in outstanding },\r\n                earnedCents = relevant\r\n                    .filter { it.paymentStatus == paidStatus }\r\n                    .sumOf { it.paidCents.toLong() }\r\n            )\r\n        }\r\n\r\n    override fun observeLessonDetails(id: Long): Flow<LessonDetails?> =\n        lessonsFlow.map { lessons -> lessons.firstOrNull { it.id == id }?.toDetailsStub() }\n\n    override fun observeByStudent(studentId: Long): Flow<List<Lesson>> =\n        lessonsFlow.map { lessons -> lessons.filter { it.studentId == studentId } }\n\n    override suspend fun getById(id: Long): Lesson? = store[id]\n\n    override suspend fun upsert(lesson: Lesson): Long {\n        val id = if (lesson.id == 0L) seq.getAndIncrement() else lesson.id\n        val existing = store[id]\n        val updated = when {\n            lesson.recurrence != null -> {\n                val seriesId = lesson.seriesId ?: existing?.seriesId ?: recurrenceSeq.getAndIncrement()\n                lesson.copy(id = id, seriesId = seriesId)\n            }\n\n            existing?.seriesId != null && lesson.seriesId == null -> {\n                lesson.copy(id = id, recurrence = null)\n            }\n\n            else -> {\n                val recurrence = existing?.recurrence\n                lesson.copy(id = id, recurrence = recurrence, seriesId = lesson.seriesId ?: existing?.seriesId)\n            }\n        }\n        store[id] = updated\n        emit()\n        return id\n    }\n\n    override suspend fun create(request: LessonCreateRequest): Long {\n        val id = seq.getAndIncrement()\n        val now = Instant.now()\n        val recurrence = request.recurrence?.let { rule ->\n            LessonRecurrence(\n                frequency = rule.frequency,\n                interval = rule.interval,\n                daysOfWeek = rule.daysOfWeek,\n                startDateTime = request.startAt,\n                untilDateTime = rule.until,\n                timezone = rule.timezone\n            )\n        }\n        val seriesId = recurrence?.let { recurrenceSeq.getAndIncrement() }\n        val newLesson = Lesson(\n            id = id,\n            studentId = request.studentId,\n            subjectId = request.subjectId,\n            title = request.title,\n            startAt = request.startAt,\n            endAt = request.endAt,\n            priceCents = request.priceCents,\n            paidCents = 0,\n            paymentStatus = PaymentStatus.UNPAID,\n            markedAt = null,\n            status = LessonStatus.PLANNED,\n            note = request.note,\n            createdAt = now,\n            updatedAt = now,\n            seriesId = seriesId,\n            isInstance = false,\n            recurrence = recurrence\n        )\n        store[id] = newLesson\n        emit()\n        return id\n    }\n\n    override suspend fun moveLesson(lessonId: Long, newStart: Instant, newEnd: Instant) {\n        store[lessonId]?.let { lesson ->\n            store[lessonId] = lesson.copy(\n                startAt = newStart,\n                endAt = newEnd,\n                updatedAt = Instant.now()\n            )\n            emit()\n        }\n    }\n\n    override suspend fun moveRecurringOccurrence(\n        seriesId: Long,\n        originalStart: Instant,\n        newStart: Instant,\n        duration: Duration\n    ) {\n        // Recurrence support is not implemented in the in-memory repository used for tests.\n    }\n\n    override suspend fun clearRecurringOverride(seriesId: Long, originalStart: Instant) {\n        // Recurrence support is not implemented in the in-memory repository used for tests.\n    }\n\r\n    override suspend fun findConflicts(start: Instant, end: Instant): List<LessonDetails> {\r\n        return store.values\r\n            .filter { lesson -> lesson.startAt < end && lesson.endAt > start }\r\n            .sortedBy { it.startAt }\r\n            .map { it.toDetailsStub() }\r\n    }\r\n\r\n    override suspend fun latestLessonForStudent(studentId: Long): Lesson? {\n        return store.values\n            .filter { it.studentId == studentId }\n            .maxByOrNull { it.startAt }\n    }\n\n    override suspend fun delete(id: Long) {\n        store.remove(id)\n        payments.remove(id)\n        emit()\n    }\n\n    override suspend fun markPaid(id: Long) {\n        store[id]?.let { lesson ->\n            val now = Instant.now()\n            val updatedLesson = lesson.copy(\n                paymentStatus = PaymentStatus.PAID,\n                paidCents = lesson.priceCents,\n                markedAt = now\n            )\n            store[id] = updatedLesson\n            val payment = payments[id]\n            payments[id] = (payment ?: Payment(\n                id = id,\n                lessonId = updatedLesson.id,\n                studentId = updatedLesson.studentId,\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.PAID,\r\n                at = now\r\n            )).copy(\r\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.PAID,\r\n                at = now\r\n            )\r\n            emit()\r\n        }\r\n    }\r\n\r\n    override suspend fun markDue(id: Long) {\r\n        store[id]?.let { lesson ->\r\n            val now = Instant.now()\n            val updatedLesson = lesson.copy(\n                paymentStatus = PaymentStatus.DUE,\n                paidCents = 0,\n                markedAt = now\n            )\n            store[id] = updatedLesson\n            val payment = payments[id]\n            payments[id] = (payment ?: Payment(\n                id = id,\n                lessonId = updatedLesson.id,\n                studentId = updatedLesson.studentId,\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.DUE,\r\n                at = now\r\n            )).copy(\r\n                amountCents = updatedLesson.priceCents,\r\n                status = PaymentStatus.DUE,\r\n                at = now\r\n            )\r\n            emit()\r\n        }\r\n    }\r\n\r\n    override suspend fun saveNote(id: Long, note: String?) {\n        store[id]?.let {\n            store[id] = it.copy(note = note)\n            emit()\n        }\n    }\n\n    override suspend fun resetPaymentStatus(id: Long) {\n        store[id]?.let { lesson ->\n            store[id] = lesson.copy(\n                paymentStatus = PaymentStatus.UNPAID,\n                paidCents = 0,\n                markedAt = null\n            )\n            payments.remove(id)\n            emit()\n        }\n    }\n\r\n    private fun emit() {\r\n        lessonsFlow.value = store.values.sortedByDescending { it.startAt }\r\n    }\r\n}\r\n\r\nprivate fun Lesson.toDetailsStub(): LessonDetails {\n    val duration = resolveDuration(startAt, endAt, null)\n    val normalizedEnd = startAt.plus(duration)\n    val recurrenceLabel = recurrence?.let { rule ->\n        val zone = rule.timezone\n        val start = rule.startDateTime.atZone(zone)\n        RecurrenceLabelFormatter.format(rule.frequency, rule.interval, rule.daysOfWeek, start)\n    }\n\n    return LessonDetails(\n        id = id,\n        baseLessonId = id,\n        studentId = studentId,\n        startAt = startAt,\n        endAt = normalizedEnd,\n        duration = duration,\n        studentName = \"Student #$studentId\",\n        studentNote = null,\r\n        subjectName = null,\n        studentGrade = null,\n        subjectColorArgb = null,\n        paymentStatus = paymentStatus,\n        paymentStatusIcon = paymentStatus.asIcon(),\n        lessonStatus = status,\n        priceCents = priceCents,\n        paidCents = paidCents,\n        lessonTitle = title,\n        lessonNote = note,\n        isRecurring = seriesId != null,\n        seriesId = seriesId,\n        originalStartAt = startAt,\n        recurrenceLabel = recurrenceLabel\n    )\n}\n\nprivate fun Lesson.toTodayStub(): LessonForToday {\n    val duration = resolveDuration(startAt, endAt, null)\n    val normalizedEnd = startAt.plus(duration)\n    val recurrenceLabel = recurrence?.let { rule ->\n        val zone = rule.timezone\n        val start = rule.startDateTime.atZone(zone)\n        RecurrenceLabelFormatter.format(rule.frequency, rule.interval, rule.daysOfWeek, start)\n    }\n\n    return LessonForToday(\n        id = id,\n        baseLessonId = id,\n        studentId = studentId,\n        studentName = \"Student #$studentId\",\n        studentGrade = null,\n        subjectName = null,\n        lessonTitle = title,\n        startAt = startAt,\n        endAt = normalizedEnd,\n        duration = duration,\n        priceCents = priceCents,\n        studentRateCents = null,\n        note = note,\n        paymentStatus = paymentStatus,\n        lessonStatus = status,\n        markedAt = markedAt,\n        isRecurring = seriesId != null,\n        seriesId = seriesId,\n        originalStartAt = startAt,\n        recurrenceLabel = recurrenceLabel\n    )\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt b/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt
--- a/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt	(revision 1e15af50832a1090ca81c6356a2d3f406bc29c28)
+++ b/app/src/main/java/com/tutorly/data/repo/memory/InMemoryLessonsRepository.kt	(date 1770120707352)
@@ -9,6 +9,7 @@
 import com.tutorly.domain.repo.LessonsRepository
 import com.tutorly.models.Lesson
 import com.tutorly.domain.recurrence.RecurrenceLabelFormatter
+import com.tutorly.models.LessonRecurrence
 import com.tutorly.models.Payment
 import com.tutorly.models.PaymentStatus
 import com.tutorly.models.LessonStatus
